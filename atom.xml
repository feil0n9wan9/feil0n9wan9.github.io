<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静静的扯淡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feilongwang.org/"/>
  <updated>2020-03-08T09:04:12.881Z</updated>
  <id>https://feilongwang.org/</id>
  
  <author>
    <name>Feilong Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LocationManager内存泄露</title>
    <link href="https://feilongwang.org/2017/07/01/Memory-Leak-in-LocationManager/"/>
    <id>https://feilongwang.org/2017/07/01/Memory-Leak-in-LocationManager/</id>
    <published>2017-07-01T12:23:04.000Z</published>
    <updated>2020-03-08T09:04:12.881Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个项目的内存优化时，偶然发现一个以前没有注意到的问题，<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>引起内存泄露，于是就想探究下泄露的Root Cause并整理出来，希望其他开发人员使用时也能够注意。<br><a id="more"></a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们先看下面的示例代码（Android 7.0）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    registerNmeaListener();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    unregisterNmeaListener();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerNmeaListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOnNmeaMessageListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mOnNmeaMessageListener = <span class="keyword">new</span> OnNmeaMessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNmeaMessage</span><span class="params">(String message, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mLocationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">        mLocationManager.addNmeaListener(mOnNmeaMessageListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unregisterNmeaListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOnNmeaMessageListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLocationManager.removeNmeaListener(mOnNmeaMessageListener);</span><br><span class="line">        mOnNmeaMessageListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一段很常规的Android代码，我们在项目中通常都会这么实现。但如果使用<a href="https://developer.android.google.cn/studio/profile/am-hprof.html" target="_blank" rel="noopener">Memory Monitor</a>来查看堆内存，就发现会有内存泄露。</p><p>使用<code>Memory Monitor</code>分析步骤如下：</p><ol><li>启动应用，然后按<code>返回</code>键退出应用。</li><li>在<code>Android Monitor</code>的<code>Memory Monitor</code>界面点击<code>Initate GC</code>。</li><li>点击<code>Dump Java Heap</code>生成<code>hprof</code>文件。生成完毕<code>Android Studio</code>会自动打开。</li><li>选择<code>Package Tree View</code>视图，并点击<code>Class Name</code>按升序排序，这样可以迅速找到要分析的程序的包名。</li><li>发现<code>MainActivity</code>的实例个数为1，即没有被GC回收，发生内存泄露。</li></ol><p><img src="/images/memory-leak-in-locationmanager/app-hprof.png" alt></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为什么会出现内存泄露？从<a href="https://developer.android.google.cn/studio/profile/am-hprof.html" target="_blank" rel="noopener">HPROF Viewer</a>的<code>Reference Tree</code>来看，<br>GC Root（Depth为0）是<code>LocationManager</code>的内部类<code>GnssStatusListenerTransport</code>成员<code>mGnssHandler</code>，<code>mGnssHandler</code>是<code>GnssStatusListenerTransport</code>的内部类<code>GnssHandler</code>的实例，所以<code>mGnssHandler</code>隐式持有外部类<code>GnssStatusListenerTransport</code>实例的引用，而<code>GnssStatusListenerTransport</code>的成员<code>mGnssNmeaListener</code>又指向了<code>MainActivity</code>的<code>OnNmeaMessageListener</code>匿名内部类实例，从而导致<code>MainActivity</code>泄露。简单概括就是：<code>mGnssHandler-&gt;GnssStatusListenerTransport-&gt;mGnssNmeaListener-&gt;MainActivity</code>。</p><p>我们可以来看一下<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>的源码，位于$SOURCEROOT/frameworks/base/location/java/android/location/LocationManager.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;OnNmeaMessageListener, GnssStatusListenerTransport&gt; mGnssNmeaListeners =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds an NMEA listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener a &#123;<span class="doctag">@link</span> OnNmeaMessageListener&#125; object to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the listener was successfully added</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if the ACCESS_FINE_LOCATION permission is not present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(ACCESS_FINE_LOCATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addNmeaListener</span><span class="params">(OnNmeaMessageListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addNmeaListener(listener, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds an NMEA listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener a &#123;<span class="doctag">@link</span> OnNmeaMessageListener&#125; object to register</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler that the listener runs on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the listener was successfully added</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if the ACCESS_FINE_LOCATION permission is not present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(ACCESS_FINE_LOCATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addNmeaListener</span><span class="params">(OnNmeaMessageListener listener, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mGpsNmeaListeners.get(listener) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// listener is already registered</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        GnssStatusListenerTransport transport =</span><br><span class="line">                <span class="keyword">new</span> GnssStatusListenerTransport(listener, handler);</span><br><span class="line">        result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            mGnssNmeaListeners.put(listener, transport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes an NMEA listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener a &#123;<span class="doctag">@link</span> OnNmeaMessageListener&#125; object to remove</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNmeaListener</span><span class="params">(OnNmeaMessageListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        GnssStatusListenerTransport transport = mGnssNmeaListeners.remove(listener);</span><br><span class="line">        <span class="keyword">if</span> (transport != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.unregisterGnssStatusCallback(transport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加listener的时候会先判断下是否已经添加过，如果添加过了，就直接返回，如果没有，则使用传入的<a href="https://developer.android.google.cn/reference/android/location/OnNmeaMessageListener.html" target="_blank" rel="noopener">OnNmeaMessageListener</a>对象和<a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>对象构造一个对应的<code>GnssStatusListenerTransport</code>对象，并将其注册到<code>LocationManagerService</code>端，同时记录在本地<code>mGnssNmeaListeners</code>表示的HashMap中。</p><p>移除listener时，先将listener从本地HashMap中移除，同时将其从<code>LocationManagerService</code>注销掉。</p><p>注册到<code>LocationManagerService</code>和从<code>LocationManagerService</code>注销的过程与我们这里分析的问题关联不大，所以就不分析了。我们主要来看<code>GnssStatusListenerTransport</code>类。Android 7.0对<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>做了较大改动，主要是增加了对GPS以外的其他卫星定位系统的支持，统称为GNSS（Global Navigation Satellite System）。这里为了流程清晰，我们把7.0兼容之前老版本的代码删除了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class is used to send Gnss status events to the client's specific thread.</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GnssStatusListenerTransport</span> <span class="keyword">extends</span> <span class="title">IGnssStatusListener</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GnssStatus.Callback mGnssCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OnNmeaMessageListener mGnssNmeaListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GnssHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GnssHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> NMEA_RECEIVED:</span><br><span class="line">                    <span class="keyword">synchronized</span> (mNmeaBuffer) &#123;</span><br><span class="line">                        <span class="keyword">int</span> length = mNmeaBuffer.size();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                            Nmea nmea = mNmeaBuffer.get(i);</span><br><span class="line">                            mGnssNmeaListener.onNmeaMessage(nmea.mNmea, nmea.mTimestamp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mNmeaBuffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GpsStatus.GPS_EVENT_STARTED:</span><br><span class="line">                    mGnssCallback.onStarted();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GpsStatus.GPS_EVENT_STOPPED:</span><br><span class="line">                    mGnssCallback.onStopped();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GpsStatus.GPS_EVENT_FIRST_FIX:</span><br><span class="line">                    mGnssCallback.onFirstFix(mTimeToFirstFix);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GpsStatus.GPS_EVENT_SATELLITE_STATUS:</span><br><span class="line">                    mGnssCallback.onSatelliteStatusChanged(mGnssStatus);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mGnssHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must not equal any of the GpsStatus event IDs</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NMEA_RECEIVED = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Nmea</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mTimestamp;</span><br><span class="line">        String mNmea;</span><br><span class="line"></span><br><span class="line">        Nmea(<span class="keyword">long</span> timestamp, String nmea) &#123;</span><br><span class="line">            mTimestamp = timestamp;</span><br><span class="line">            mNmea = nmea;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Nmea&gt; mNmeaBuffer;</span><br><span class="line"></span><br><span class="line">    GnssStatusListenerTransport(GnssStatus.Callback callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GnssStatusListenerTransport(GnssStatus.Callback callback, Handler handler) &#123;</span><br><span class="line">        mOldGnssCallback = <span class="keyword">null</span>;</span><br><span class="line">        mGnssCallback = callback;</span><br><span class="line">        mGnssHandler = <span class="keyword">new</span> GnssHandler(handler);</span><br><span class="line">        mOldGnssNmeaListener = <span class="keyword">null</span>;</span><br><span class="line">        mGnssNmeaListener = <span class="keyword">null</span>;</span><br><span class="line">        mNmeaBuffer = <span class="keyword">null</span>;</span><br><span class="line">        mGpsListener = <span class="keyword">null</span>;</span><br><span class="line">        mGpsNmeaListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GnssStatusListenerTransport(OnNmeaMessageListener listener) &#123;</span><br><span class="line">        <span class="keyword">this</span>(listener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GnssStatusListenerTransport(OnNmeaMessageListener listener, Handler handler) &#123;</span><br><span class="line">        mOldGnssCallback = <span class="keyword">null</span>;</span><br><span class="line">        mGnssCallback = <span class="keyword">null</span>;</span><br><span class="line">        mGnssHandler = <span class="keyword">new</span> GnssHandler(handler);</span><br><span class="line">        mOldGnssNmeaListener = <span class="keyword">null</span>;</span><br><span class="line">        mGnssNmeaListener = listener;</span><br><span class="line">        mGpsListener = <span class="keyword">null</span>;</span><br><span class="line">        mGpsNmeaListener = <span class="keyword">null</span>;</span><br><span class="line">        mNmeaBuffer = <span class="keyword">new</span> ArrayList&lt;Nmea&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGnssStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGpsListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = GpsStatus.GPS_EVENT_STARTED;</span><br><span class="line">            mGnssHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGnssStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGpsListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = GpsStatus.GPS_EVENT_STOPPED;</span><br><span class="line">            mGnssHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFirstFix</span><span class="params">(<span class="keyword">int</span> ttff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGpsListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimeToFirstFix = ttff;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = GpsStatus.GPS_EVENT_FIRST_FIX;</span><br><span class="line">            mGnssHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSvStatusChanged</span><span class="params">(<span class="keyword">int</span> svCount, <span class="keyword">int</span>[] prnWithFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span>[] cn0s, <span class="keyword">float</span>[] elevations, <span class="keyword">float</span>[] azimuths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGnssCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mGnssStatus = <span class="keyword">new</span> GnssStatus(svCount, prnWithFlags, cn0s, elevations, azimuths);</span><br><span class="line"></span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = GpsStatus.GPS_EVENT_SATELLITE_STATUS;</span><br><span class="line">            <span class="comment">// remove any SV status messages already in the queue</span></span><br><span class="line">            mGnssHandler.removeMessages(GpsStatus.GPS_EVENT_SATELLITE_STATUS);</span><br><span class="line">            mGnssHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNmeaReceived</span><span class="params">(<span class="keyword">long</span> timestamp, String nmea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGnssNmeaListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mNmeaBuffer) &#123;</span><br><span class="line">                mNmeaBuffer.add(<span class="keyword">new</span> Nmea(timestamp, nmea));</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = NMEA_RECEIVED;</span><br><span class="line">            <span class="comment">// remove any NMEA_RECEIVED messages already in the queue</span></span><br><span class="line">            mGnssHandler.removeMessages(NMEA_RECEIVED);</span><br><span class="line">            mGnssHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GnssStatusListenerTransport继承自<code>IGnssStatusListener.Stub</code>，熟悉<code>Binder</code>机制的同学都知道，<code>Stub</code>类展开之后的形式是<code>Stub extends Binder(implements IBinder) implements IGnssStatusListener(implements IInterface)</code>，它是<code>Binder</code>通信的本地对象，将一个<code>Binder</code>本地对象传给另一个进程，另一个进程会拿到一个<code>Binder</code>通信的<code>Proxy</code>对象，这样另一个进程就可以通过<code>Proxy</code>对象调用本地对象的方法了，而<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>中又持有<code>LocationManagerService</code>的<code>Proxy</code>对象，这样<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>和<code>LocationManagerService</code>就可以双向通信。</p><p>这里<code>IGnssStatusListener</code>主要提供了5个方法供<code>LocationManagerService</code>回调以便通知相应的GNSS事件，其源码位于$SOURCEROOT/frameworks/base/location/java/android/location/IGnssStatusListener.aidl：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright (C) 2008, The Android Open Source Project</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package android.location;</span><br><span class="line"></span><br><span class="line">import android.location.Location;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@hide&#125;</span><br><span class="line"> */</span><br><span class="line">oneway interface IGnssStatusListener</span><br><span class="line">&#123;</span><br><span class="line">    void onGnssStarted();</span><br><span class="line">    void onGnssStopped();</span><br><span class="line">    void onFirstFix(int ttff);</span><br><span class="line">    void onSvStatusChanged(int svCount, in int[] svidWithFlags, in float[] cn0s,</span><br><span class="line">            in float[] elevations, in float[] azimuths);</span><br><span class="line">    void onNmeaReceived(long timestamp, String nmea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在<code>GnssStatusListenerTransport</code>对<code>IGnssStatusListener</code>的接口实现里，主要是将<code>LocationManagerService</code>回传的事件通过<code>mGnssHandler</code>进行异步转发。<code>mGnssHandler</code>是<code>GnssStatusListenerTransport</code>的内部类<code>GnssHandler</code>的实例，它在<code>GnssStatusListenerTransport</code>的构造函数中被创建。这里我们注意到，<code>mGnssHandler</code>的构造与外部传入的<code>Handler</code>对象有关。如果外部传入了<code>Handler</code>对象，则<code>mGnssHandler</code>绑定到外部传入的<code>Handler</code>对象所绑定的消息队列，如果外部传入的<code>Handler</code>对象为<code>null</code>，则<code>mGnssHandler</code>绑定到调用<code>addNmeaListener</code>方法所在的线程的消息队列。接下来，我们看<code>GnssHandler</code>的<a href="https://developer.android.google.cn/reference/android/os/Handler.html#handleMessage&#40;android.os.Message&#41;" target="_blank" rel="noopener">handleMessage</a>实现，这里的实现比较简单，就直接将事件通知给对应的listener。</p><p>看到这里，估计大家也发现了，这里的<code>mGnssHandler</code>可能会引发内存泄露，因为在调用<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html#removeNmeaListener&#40;android.location.OnNmeaMessageListener&#41;" target="_blank" rel="noopener">LocationManager.removeNmeaListener</a>时并没有任何清除与<code>mGnssHandler</code>关联的<code>Message</code>的操作。<a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>可能引起内存泄露请参考<a href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html" target="_blank" rel="noopener">http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html</a>。</p><p>对应到我们当前的场景，发生泄露的一个可能情况是<code>LocationManagerService</code>不断给<code>GnssStatusListenerTransport</code>对象发送信息，这些信息被<code>mGnssHandler</code>封装成<code>Message</code>投递到<code>mGnssHandler</code>绑定的消息队列里，这里就是主线程消息队列，当我们在主线程调用<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html#removeNmeaListener&#40;android.location.OnNmeaMessageListener&#41;" target="_blank" rel="noopener">LocationManager.removeNmeaListener</a>方法时，<code>mGnssHandler</code>可能已经往主线程的消息队列里投递了N多个消息。也就是说在主线程的消息队列里面，<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onDestroy&#40;&#41;" target="_blank" rel="noopener">Activity.onDestroy</a>的消息后面有很多<code>mGnssHandler</code>投递的消息。这些<code>mGnssHandler</code>投递的位于<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onDestroy&#40;&#41;" target="_blank" rel="noopener">Activity.onDestroy</a>之后的消息如果在<a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>退出时没有被清除的话，就会发生<a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>退出了，但是引用链<code>Message-&gt;mGnssHandler-&gt;GnssStatusListenerTransport-&gt;mGnssNmeaListener-&gt;MainActivity</code>还在，导致<code>MainActivity</code>泄露。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>分析到这里就完了吗？显然不是。我们可以进一步思考：</p><ol><li><p><code>mGnssHandler</code>投递的那些可能造成内存泄露的<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a>也没有使用delay的方式投递，也就是说，<a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>退出过不了多久，这些<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a>就会被处理完，即 内存泄露一段时间后就会恢复正常，<code>MainActivity</code>又可以给被回收了。但事实确实如此吗？通过测试我们可以发现，即使过了很长时间，<code>MainActivity</code>依然回收不了。</p></li><li><p><code>Memory Monitor</code>显示GC Root是<code>mGnssHandler</code>，所以很可能不是<code>Message-&gt;mGnssHandler</code>导致泄露。Android中的GC Root主要包括如下几类，可以<a href="https://developer.android.google.cn/studio/profile/am-memory.html" target="_blank" rel="noopener">参考</a>，<code>mGssHandler</code>属于哪一类？如果有人知道，也请告诉我一下（参考2017/07/02更新）。</p><ul><li>references on the stack</li><li>Java Native Interface (JNI) native objects and memory</li><li>static variables and functions</li><li>threads and objects that can be referenced</li><li>classes loaded by the bootstrap loader</li><li>finalizers and unfinalized objects</li><li>busy monitor objects</li></ul></li><li><p><a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>内存泄露的问题早在2009年就被提出来了，为什么现在Android发展到了7.0，还会出现这种问题。我们查看Android源代码中<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>的提交历史，发现<code>GnssHandler</code>的机制（或者类似机制）在<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>内部已历经几个Android版本，难道就一直没人发现这个问题吗？我们在<a href="https://issuetracker.google.com" target="_blank" rel="noopener">Google Issue Tracker</a>中搜索LocationManager leak，发现确实有一些相关的<a href="https://issuetracker.google.com/issues?q=LocationManager%20leak" target="_blank" rel="noopener">issue</a>，但这些issue不知道为何最后要么不了了之，要么被Google没有任何解释就直接关闭了。</p></li><li>我们在Android的源码里搜索<a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>，看Android内置程序如何使用<a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>时会发现，在Android源码内部有些地方处理了泄露，如TV内部使用<a href="https://android.googlesource.com/platform/packages/apps/TV/+/master/common/src/com/android/tv/common/WeakHandler.java" target="_blank" rel="noopener">WeakHandler</a>，有些地方没有处理泄露，即在Android源码内部对<a href="https://developer.android.google.cn/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a>的处理并未统一。</li><li><p>另外我们在<a href="https://stackoverflow.com/questions/21305233/locationlistener-and-memory-leaks" target="_blank" rel="noopener">StackOverflow</a>上发现这篇帖子，于是尝试将程序改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onResume();</span><br><span class="line">      registerNmeaListener();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onPause();</span><br><span class="line">      unregisterNmeaListener();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>竟然意外的发现<strong>内存泄露消失</strong>了。但是我们知道按<code>返回</code>建退出应用时，<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>，<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onStop&#40;&#41;" target="_blank" rel="noopener">onStop</a>和<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onDestroy&#40;&#41;" target="_blank" rel="noopener">onDestroy</a>是在同一个<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a>里处理的。具体可以参见<code>ActivityThread.performDestroyActivity</code>，源码位于$SOURCEROOT/frameworks/base/core/java/android/app/ActivityThread.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing finish of "</span> + r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activityClass = r.activity.getClass();</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.activity.performStop(r.mPreserveWindow);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to stop activity "</span></span><br><span class="line">                            + safeToComponentShortString(r.intent)</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            EventLog.writeEvent(LOG_AM_ON_STOP_CALLED, UserHandle.myUserId(),</span><br><span class="line">                    r.activity.getComponentName().getClassName(), <span class="string">"destroy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.lastNonConfigurationInstances</span><br><span class="line">                        = r.activity.retainNonConfigurationInstances();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to retain activity "</span></span><br><span class="line">                            + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                    <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.window.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to destroy activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivities.remove(token);</span><br><span class="line">    StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是在同一个<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a>里处理，那为何在<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>中移除listener不会造成泄露，而在<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onStop&#40;&#41;" target="_blank" rel="noopener">onStop</a>中移除listener就会造成内存泄露？</p></li></ol><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>  虽然现在我们还有很多暂时无法解答的问题，但对出现的问题我们还是有要解决方案。</p><h4 id="在onPause移除listener"><a href="#在onPause移除listener" class="headerlink" title="在onPause移除listener"></a>在<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>移除listener</h4><p>从之前分析来看，如果业务满足在<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>中移除listener的情况则可以使用此方法完美解决。若业务不满足在<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>中移除listener的情况（因为进入<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onPause&#40;&#41;" target="_blank" rel="noopener">onPause</a>时Activity可能没有被完全遮挡，所以底层视图还是需要更新，因此对于这种情况，我们不能移除listener），我们只能采用work around的方式。</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>可以通过反射拿到<code>mGnssHandler</code>的引用，然后移除所有相关的消息，并将<code>GnssStatusListenerTransport</code>内部<code>mGnssNmeaListener</code>的引用置<code>null</code>。</p><h4 id="使用SoftReference和Application-Context"><a href="#使用SoftReference和Application-Context" class="headerlink" title="使用SoftReference和Application Context"></a>使用<a href="https://developer.android.google.cn/reference/java/lang/ref/SoftReference.html" target="_blank" rel="noopener">SoftReference</a>和<a href="https://developer.android.google.cn/reference/android/app/Application.html" target="_blank" rel="noopener">Application</a> Context</h4><p>我们可以实现一个足够小的静态的<a href="https://developer.android.google.cn/reference/android/location/OnNmeaMessageListener.html" target="_blank" rel="noopener">OnNmeaMessageListener</a>内部类并持有外部<code>MainActivity</code>的软引用，然后将<a href="https://developer.android.google.cn/reference/android/location/OnNmeaMessageListener.html" target="_blank" rel="noopener">OnNmeaMessageListener</a>接收到的所有事件转发给外部的<code>MainActivity</code>来处理，以保持内部类足够小。</p><p>使用SoftReference的方式很好理解，但为什么要同时使用Application Context呢？这是因为GnssStatusListenerTransport无法被回收会导致LocationManager无法回收，而LocationManager持有调用getSystemService的调用者的Context。在我们这个场景中就是<code>MainActivity</code>，因此还是会导致<code>MainActivity</code>泄露。使用Application Context使得整个应用只会构造一个LocationManager，这点可以从<code>SystemServiceRegistry</code>源码来看，源码位于$SOURCEROOT/frameworks/base/core/java/android/app/SystemServiceRegistry.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.LOCATION_SERVICE, LocationManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LocationManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocationManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocationManager(ctx, ILocationManager.Stub.asInterface(b));</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>我们知道<a href="https://developer.android.google.cn/reference/android/content/Context.html" target="_blank" rel="noopener">Context</a>采用了设计模式里的装饰模式，<code>ContextImpl</code>是<code>ContextWrapper</code>（Activity和Application的父类）真正做事情的类，同时<code>ContextImpl</code>内部持有Out Context，即<code>ContextWrapper</code>的引用。从SystemServiceRegistry可以看出，LocationManager与<code>ContextWrapper</code>是一一对应的关系，即使用LocationManager的每一个Activity都会创建一个LocationManager的实例。在我们这个场景中LocationManager持有ContextImpl的引用，ContextImpl持有Out Context，即<code>MainActivity</code>或<code>Application</code>的引用，从而导致<code>MainActivity</code>泄露，而统一使用Application Context则不会有这个问题。</p><p>好了，到此我们整个LocationManager泄露的问题就说完了。对于前面还无法的解答的问题，我会继续分析。如果有人知道答案，也请告诉我一声。</p><h3 id="Updated-2017-07-02"><a href="#Updated-2017-07-02" class="headerlink" title="Updated 2017/07/02"></a>Updated 2017/07/02</h3><p>当我们使用上述反射机制解决了<code>MainActivity</code>的内存泄露时，<code>android.location</code>包的内存泄露还是存在的。此时我们通过<code>Memory Monitor</code>来进一步分析<code>android.location</code>包的堆内存情况，如下图：<br><img src="/images/memory-leak-in-locationmanager/location-hprof.png" alt><br>GC Root是<code>GnssStatusListenerTransport</code>，并且除了<code>FinalizerReference</code>，没有其他引用指向它。<code>FinalizerReference</code>是Android framework的一个隐藏类，主要用来实现Java的<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.6" target="_blank" rel="noopener">finalize机制</a>。所有重写finalize()方法的类对象，最后都会被FinalizerReference类的静态变量引用，所以当它们没有强引用时不会被虚拟机立即回收，而是GC会将这些重写了finalize()方法的对象压入到ReferenceQueue中。同时会有一个守护线程<code>Finalize Daemon</code>来真正处理调用他们的<code>finalize</code>函数，实现垃圾回收。所以重写了finalize()方法的类对象需要至少经过两轮GC才有可能被释放，具体释放时机不确定。这与我们前面介绍Android GC Root有一类是<code>finalizers and unfinalized objects</code>不谋而合。</p><p>但是我们在<code>GnssStatusListenerTransport</code>并没有发现<code>finalize()</code>被重写，这到底是怎么回事呢？相信大家一定也猜到了：在父类里重写了。我们依次查看<code>GnssStatusListenerTransport</code>的父类，发现<a href="https://developer.android.google.cn/reference/android/os/Binder.html" target="_blank" rel="noopener">Binder</a>类重写了<code>finalize()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，我们终于找到了<a href="https://developer.android.google.cn/reference/android/location/LocationManager.html" target="_blank" rel="noopener">LocationManager</a>泄露的Root Cause。Android系统要解决这个问题，可以在<code>GnssStatusListenerTransport</code>类中添加一个cleanup的方法来清除所有的外部引用，然后在移除listener之后调用一下cleanup方法即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一个项目的内存优化时，偶然发现一个以前没有注意到的问题，&lt;a href=&quot;https://developer.android.google.cn/reference/android/location/LocationManager.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LocationManager&lt;/a&gt;引起内存泄露，于是就想探究下泄露的Root Cause并整理出来，希望其他开发人员使用时也能够注意。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://feilongwang.org/tags/Android/"/>
    
      <category term="LocationManager" scheme="https://feilongwang.org/tags/LocationManager/"/>
    
      <category term="Memory Leak" scheme="https://feilongwang.org/tags/Memory-Leak/"/>
    
      <category term="Leak" scheme="https://feilongwang.org/tags/Leak/"/>
    
  </entry>
  
  <entry>
    <title>Android Things</title>
    <link href="https://feilongwang.org/2017/01/05/Android-Things/"/>
    <id>https://feilongwang.org/2017/01/05/Android-Things/</id>
    <published>2017-01-05T13:52:48.000Z</published>
    <updated>2020-03-08T09:05:12.561Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.google.com.hk/" target="_blank" rel="noopener">Google</a>于12月13日对外发布了其新一代物联网操作系统<a href="https://developer.android.com/things/index.html" target="_blank" rel="noopener">Android Things</a>，它的愿景是为各种消费、零售和工业应用程序提供互连的设备，并提供完整立即可用的硬件解决方案，以进一步实现<a href="https://developer.android.com/things/index.html" target="_blank" rel="noopener">If you can build an app, you can build a device</a>。<br><a id="more"></a></p><p><a href="https://developer.android.com/things/index.html" target="_blank" rel="noopener">Android Things</a>的前身是<a href="https://www.google.com.hk/" target="_blank" rel="noopener">Google</a>在其<a href="https://baike.baidu.com/item/Google%20I%2FO?fr=aladdin" target="_blank" rel="noopener">2015年I/O全球开发者大会</a>上推出的基于<a href="https://www.android.com" target="_blank" rel="noopener">Android</a>的物联网项目<a href="https://android.googlesource.com/brillo/manifest/" target="_blank" rel="noopener">Brillo</a>。然而经过一年多的发展，由于使用C/C++基于NDK进行开发，并且缺乏相应的开发工具，<a href="https://android.googlesource.com/brillo/manifest/" target="_blank" rel="noopener">Brillo</a>项目未能吸引足够的开发人员加入。<a href="https://developer.android.com/things/index.html" target="_blank" rel="noopener">Android Things</a>吸取了<a href="https://android.googlesource.com/brillo/manifest/" target="_blank" rel="noopener">Brillo</a>项目的反馈，通过Java API面向广大的Android和Java开发者，并加入了熟悉的工具，如<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>，<a href="https://developer.android.com/ndk/index.html" target="_blank" rel="noopener">Android SDK</a>，<a href="https://developers.google.com/android/guides/overview" target="_blank" rel="noopener">Google Play服务</a>和<a href="https://cloud.google.com/" target="_blank" rel="noopener">Google云平台</a>等。</p><h3 id="Android-Things架构"><a href="#Android-Things架构" class="headerlink" title="Android Things架构"></a>Android Things架构</h3><p>先看Brillo和Android Things的架构图对比：</p><p>这是<strong>Brillo</strong>：<br><img src="/images/android-things/brillo-architecture.png" alt><br>这是<strong>Android Things</strong>：<br><img src="/images/android-things/androidthings-architecture.png" alt></p><p><strong>可以很清楚的看出来</strong>：</p><ul><li>Brillo是一个非常精剪的Androd运行时环境，没有ART，可以看成只运行Linux内核和部分Android本地库的Android系统，可以运行的硬件最低配置为32M内存和128M存储，使用C/C++基于NDK进行开发，开发和部署明显不同于<a href="https://www.android.com" target="_blank" rel="noopener">核心Android</a>。Android Things与<a href="https://www.android.com" target="_blank" rel="noopener">核心Android</a>框架大致相同，支持<a href="https://developers.google.com/android/" target="_blank" rel="noopener">Google APIs for Android</a>的一个子集，并通过引入<a href="https://developer.android.com/things/sdk/index.html#things_support_library" target="_blank" rel="noopener">Things Support Library</a>提供了额外的API，这些API支持创建用户驱动程序，允许应用集成原先没有的新硬件。</li><li><a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>，<a href="https://developers.google.com/android/guides/overview" target="_blank" rel="noopener">Google Play服务</a>，<a href="https://firebase.google.com/" target="_blank" rel="noopener">Firebase</a>，<a href="https://developers.google.com/weave/" target="_blank" rel="noopener">Weave</a>和活跃的开发者社区形成了完整的开发生态。如果你喜欢，你甚至可以在<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>中使用C/C++进行开发。</li><li>利用Android系统的<a href="https://source.android.com/devices/tech/ota/index.html" target="_blank" rel="noopener">OTA更新</a>机制，设备能够及时收到Google官方安全更新、bug fixes等，开发人员能够集中精力于构建产品本身。</li><li>不管是Brillo还是Android Things均运行于Linux之上，而Linux是一个使用<a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">虚拟内存</a>技术的操作系统。这意味着Android Things所运行的处理器必须支持虚拟内存，换句话说，Android Things所运行的处理器是一个拥有完<a href="https://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="noopener">MMU</a>的处理器。</li></ul><h3 id="Android-Things协议"><a href="#Android-Things协议" class="headerlink" title="Android Things协议"></a>Android Things协议</h3><p>Android Things默认集成<a href="https://developers.google.com/weave/" target="_blank" rel="noopener">Weave</a>协议。<a href="https://developers.google.com/weave/" target="_blank" rel="noopener">Weave</a>是一个物联网通讯协议，不仅支持设备与设备连接，还支持手机与设备连接，手机、设备连接至Google服务的强大能力。同时，<a href="https://developers.google.com/weave/" target="_blank" rel="noopener">Weave</a>也不依赖于任何通信协议，它可以运行在Wi-Fi，BLE，Zigbee等常见的通信协议之上。<img src="/images/android-things/images/weave.jpg" alt><br>由于<a href="https://developers.google.com/weave/" target="_blank" rel="noopener">Weave</a>被设计为一个平台无关的通信协议，针对不同的目标设备，包括资源受限的嵌入式设备，Weave通过引入不同的实现方式来应对。这些不同目标设备上的代码或组件，共同组合了Weave。</p><p>Weave提供了一套标准的设备操作命令（叫做Schema），以及对应的认证机制。Weave对常见的物联网设备，当前主要是智能家居设备，进行了总结和抽象，并形成了一套固定的操作命令集合，内部叫做Schema，并以<a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">JSON格式</a>进行描述。Weave这样做的目标，是希望达到不同设备厂商的设备之间，只要使用了Weave，就可以相互操作的目的。同时Weave还引入了一套认证机制，不在标准schema框架内的设备及操作，可以经过Google的认证后，添加到标准schema中。这样就确保了整个schema框架的可扩展性，长此以往，就可以形成一个完整和丰富的生态链。</p><h3 id="Android-Things硬件"><a href="#Android-Things硬件" class="headerlink" title="Android Things硬件"></a>Android Things硬件</h3><p>Android Things与SoC厂商合作，通过提供包含SoMs（System-on-Modules）的认证开发板使得开发者即使不了解嵌入式系统设计也能够快速开发完整的产品。SoMs将SoC，内存，Flash存储，WiFi，蓝牙等整合在一块开发板上。一站式硬件解决方案、Google管理BSP支持以及基于Android SDK、Android Studio的软件开发平台，极大的降低了开发门槛及成本。</p><p>Android Things现在官方支持的开发板包括<a href="https://developer.android.com/things/hardware/edison.html" target="_blank" rel="noopener">Intel Edison</a>，<a href="https://developer.android.com/things/hardware/joule.html" target="_blank" rel="noopener">Intel Joule</a>（Android Things Developer Preview 2新增），<a href="https://developer.android.com/things/hardware/pico.html" target="_blank" rel="noopener">NXP Pico i.MX6UL</a>，<a href="https://developer.android.com/things/hardware/raspberrypi.html" target="_blank" rel="noopener">Raspberry Pi 3</a>，厂商可以通过<a href="https://developer.android.com/things/hardware/partner-toolkit.html#messaging_guidelines" target="_blank" rel="noopener">Partner ToolKit</a>来申请Android Things的官方认证。</p><h3 id="Android-Things-SDK"><a href="#Android-Things-SDK" class="headerlink" title="Android Things SDK"></a>Android Things SDK</h3><p>Android Things通过<a href="https://developer.android.com/things/sdk/index.html#things_support_library" target="_blank" rel="noopener">Things Support Library</a>提供额外的APIs扩展了核心Android的功能，这些APIs允许应用程序整合新的硬件类型。同时，Android Things平台被设计为单应用模式的线性结构，应用程序开机自动启动，没有其他系统应用。</p><h4 id="Things-Support-Library"><a href="#Things-Support-Library" class="headerlink" title="Things Support Library"></a>Things Support Library</h4><p><a href="https://developer.android.com/things/sdk/index.html#things_support_library" target="_blank" rel="noopener">Things Support Library</a>主要包括外设I/O API和用户驱动API。外设I/O API使得应用能够使用业界标准的协议和接口（当前包括GPIO，PWM，I2C，SPI，UART）与传感器、电动机等通信。用户驱动API允许应用程序注入硬件事件到系统框架，以便其他应用程序能够通过标准APIs感知这些硬件事件。</p><h4 id="相比核心Android行为变更"><a href="#相比核心Android行为变更" class="headerlink" title="相比核心Android行为变更"></a>相比核心Android行为变更</h4><ul><li>Android Things不包含标准的系统应用和内容提供者套件，所以开发Android Things应用应避免使用<a href="https://developer.android.com/guide/components/intents-common.html" target="_blank" rel="noopener">common intents</a>，以及内容提供者，包括<a href="https://developer.android.com/reference/android/provider/CalendarContract.html" target="_blank" rel="noopener">CalendarContract</a>，<a href="https://developer.android.com/reference/android/provider/ContactsContract.html" target="_blank" rel="noopener">ContactsContract</a>，<a href="https://developer.android.com/reference/android/provider/DocumentsContract.html" target="_blank" rel="noopener">DocumentsContract</a>，<a href="https://developer.android.com/reference/android/app/DownloadManager.html" target="_blank" rel="noopener">DownloadManager</a>，<a href="https://developer.android.com/reference/android/provider/MediaStore.html" target="_blank" rel="noopener">MediaStore</a>，<br><a href="https://developer.android.com/reference/android/provider/Settings.html" target="_blank" rel="noopener">Settings</a>，<a href="https://developer.android.com/reference/android/provider/Telephony.html" target="_blank" rel="noopener">Telephony</a>，<a href="https://developer.android.com/reference/android/provider/UserDictionary.html" target="_blank" rel="noopener">UserDictionary</a>，<a href="https://developer.android.com/reference/android/provider/VoicemailContract.html" target="_blank" rel="noopener">VoicemailContract</a>。</li><li>Android Things不强制要求显示屏，且即使在图形模式下，Android Things并不包含系统状态栏和底部导航栏。</li><li>Android Things要求应用程序在menifest文件中导出”home activiy“作为系统主入口，以便设备启动时能够自动启动。<a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>可以通过添加一个包含<code>CATEGORY_DEFAULT</code>和<code>IOT_LAUNCHER</code>的<a href="https://developer.android.com/reference/android/content/IntentFilter.html" target="_blank" rel="noopener">intent filter</a>即可实现。</li><li>Android Things支持部分Google Service APIs，通常，那些需要用户输入和证书认证的APIs是不可用的。同时，Android Things不支持<a href="https://developer.android.com/distribute/googleplay/index.html" target="_blank" rel="noopener">Google Play Store</a>，所以设备中的Play Services版本是静态的、不会自动更新的。</li><li>Android Things不支持动态权限，因为嵌入式设备不确定是否有显示屏来接受运行时对话框。应用程序在manifest文件中声明的所有权限都会在应用程序安装时全部授权。</li><li>Android Things因为没有系统状态栏，所有也不支持系统通知。</li></ul><h3 id="Android-Things开发"><a href="#Android-Things开发" class="headerlink" title="Android Things开发"></a>Android Things开发</h3><p>Android Things应用程序与核心Android应用程序有相同的结构，所以你可以通过修改现有应用程序或基于现有应用程序创建新的应用来开发Android Things应用程序。同时，你还需要一块运行<a href="https://developer.android.com/things/hardware/developer-kits.html" target="_blank" rel="noopener">Android Things的开发板</a>。</p><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><ul><li>SDK工具版本24及以上。</li><li>平台版本Android 7.0（API 24）及以上。</li><li>设置应用程序的targetSdkVersion设置为Android 7.0（API 24）及以上。</li></ul><h4 id="添加Things-Support-Library依赖库"><a href="#添加Things-Support-Library依赖库" class="headerlink" title="添加Things Support Library依赖库"></a>添加Things Support Library依赖库</h4><p>1.在应用级别的build.gradle添加依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    provided &apos;com.google.android.things:androidthings:0.2-devpreview&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>provided</code>依赖配置表明应用程序在设备上运行时应使用设备上已存在的共享库。</p></blockquote><p>2.在manifest文件中声明使用共享库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;application ...&gt;</span><br><span class="line">    &lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure></p><h4 id="声明Home-Activity"><a href="#声明Home-Activity" class="headerlink" title="声明Home Activity"></a>声明Home Activity</h4><p>Android Things上运行的应用程序必须在manifest文件里声明一个activity作为系统启动后的主入口。声明一个包含如下属性的<a href="https://developer.android.com/reference/android/content/IntentFilter.html" target="_blank" rel="noopener">intent filter</a>：</p><ul><li><strong>Action</strong>：<a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_MAIN" target="_blank" rel="noopener">ACTION_MAIN</a></li><li><strong>Category</strong>：<a href="https://developer.android.com/reference/android/content/Intent.html#CATEGORY_DEFAULT" target="_blank" rel="noopener">CATEGORY_DEFAULT</a></li><li><strong>Category</strong>：<code>IOT_LAUNCHER</code></li></ul><p>为了方便开发，同一个Activity应包含一个<a href="https://developer.android.com/reference/android/content/Intent.html#CATEGORY_LAUNCHER" target="_blank" rel="noopener">CATEGORY_LAUNCHER</a> intent filter，以便Android Studio能默认启动它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">    &lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt;</span><br><span class="line">    &lt;activity android:name=&quot;.HomeActivity&quot;&gt;</span><br><span class="line">        &lt;!-- Launch activity as default from Android Studio --&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Launch activity automatically on boot --&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure></p><p>更多开发内容，请参考<a href="https://developer.android.com/things/sdk/samples.html" target="_blank" rel="noopener">Samples</a>和<a href="https://github.com/androidthings" target="_blank" rel="noopener">GitHub</a>。</p><hr><p>参考</p><ul><li><a href="https://developer.android.com/things/index.html" target="_blank" rel="noopener">https://developer.android.com/things/index.html</a></li><li><a href="https://www.leiphone.com/news/201612/bTY6FmG2EncrijnD.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201612/bTY6FmG2EncrijnD.html</a></li><li><a href="https://www.diycode.cc/topics/518" target="_blank" rel="noopener">https://www.diycode.cc/topics/518</a></li><li><a href="https://blog.csdn.net/hellochina15/article/details/51969995" target="_blank" rel="noopener">https://blog.csdn.net/hellochina15/article/details/51969995</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.google.com.hk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google&lt;/a&gt;于12月13日对外发布了其新一代物联网操作系统&lt;a href=&quot;https://developer.android.com/things/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Things&lt;/a&gt;，它的愿景是为各种消费、零售和工业应用程序提供互连的设备，并提供完整立即可用的硬件解决方案，以进一步实现&lt;a href=&quot;https://developer.android.com/things/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;If you can build an app, you can build a device&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://feilongwang.org/tags/Android/"/>
    
      <category term="Things" scheme="https://feilongwang.org/tags/Things/"/>
    
      <category term="IoT" scheme="https://feilongwang.org/tags/IoT/"/>
    
      <category term="Brillo" scheme="https://feilongwang.org/tags/Brillo/"/>
    
  </entry>
  
  <entry>
    <title>Android更新概述</title>
    <link href="https://feilongwang.org/2016/10/30/The-Changes-in-Different-Android-Versions/"/>
    <id>https://feilongwang.org/2016/10/30/The-Changes-in-Different-Android-Versions/</id>
    <published>2016-10-30T14:40:29.000Z</published>
    <updated>2020-03-01T02:17:43.949Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.android.com" target="_blank" rel="noopener">Android</a>每个版都会加入很多新功能，我们可以从官方文档<a href="https://developer.android.com/about/versions/oreo/index.html" target="_blank" rel="noopener">Android Developers-&gt;Home-&gt;Android</a>查看<a href="https://www.android.com" target="_blank" rel="noopener">Android</a>每个版本更新的具体内容。本文是对<a href="https://developer.android.com/about/versions/oreo/index.html" target="_blank" rel="noopener">Android Developers-&gt;Home-&gt;Android</a>官方文档的中文翻译。<br><a id="more"></a></p><p><strong>本文档已迁移至GitHub</strong> - <a href="https://github.com/feil0n9wan9/android-about-versions-in-chinese" target="_blank" rel="noopener">Android官方版本更新说明中文版</a>。<strong>欢迎大家参与此开源协作翻译项目</strong>。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><a href="/android-about-versions-in-chinese/oreo/index.html">Oreo奥利奥</a><ul><li><a href="/android-about-versions-in-chinese/oreo/android-8.0.html">Android 8.0功能和APIs</a></li><li><a href="/android-about-versions-in-chinese/oreo/android-8.0-changes.html">Android 8.0行为变更</a></li><li><a href="/android-about-versions-in-chinese/oreo/android-8.0-migration.html">迁移到Android 8.0</a></li><li><a href="/android-about-versions-in-chinese/oreo/android-8.0-samples.html">Android 8.0示例</a></li><li><a href="/android-about-versions-in-chinese/oreo/background.html">后台执行限制</a></li><li><a href="/android-about-versions-in-chinese/oreo/background-location-limits.html">后台位置限制</a></li></ul></li><li><a href="/android-about-versions-in-chinese/nougat.html">Nougat牛轧糖</a><ul><li><a href="/android-about-versions-in-chinese/android-7.1.html">Android 7.1于开发者</a></li><li><a href="/android-about-versions-in-chinese/android-7.1-samples.html">Android 7.1示例</a></li><li><a href="/android-about-versions-in-chinese/android-7.0.html">Android 7.0于开发者</a></li><li><a href="/android-about-versions-in-chinese/android-7.0-changes.html">Android 7.0行为变更</a></li><li><a href="/android-about-versions-in-chinese/android-7.0-samples.html">Android 7.0示例</a></li></ul></li><li><a href="/android-about-versions-in-chinese/marshmallow.html">Marshmallow棉花糖</a><ul><li><a href="/android-about-versions-in-chinese/android-6.0.html">Android 6.0 APIs</a></li><li><a href="/android-about-versions-in-chinese/android-6.0-changes.html">Android 6.0变更</a></li><li><a href="/android-about-versions-in-chinese/android-6.0-samples.html">Android 6.0示例</a></li><li><a href="/android-about-versions-in-chinese/android-6.0-testing.html">Android 6.0测试</a></li></ul></li><li><a href="/android-about-versions-in-chinese/lollipop.html">Lollipop棒棒糖</a><ul><li><a href="/android-about-versions-in-chinese/android-5.1.html">Android 5.1 APIs</a></li><li><a href="/android-about-versions-in-chinese/android-5.0.html">Android 5.0 APIs</a></li><li><a href="/android-about-versions-in-chinese/android-5.0-changes.html">Android 5.0变更</a></li></ul></li><li><a href="/android-about-versions-in-chinese/kitkat.html">KitKat奇巧</a><ul><li><a href="/android-about-versions-in-chinese/android-4.4.html">Android 4.4 APIs</a></li></ul></li><li><a href="/android-about-versions-in-chinese/jelly-bean.html">Jelly Bean果冻豆</a><ul><li><a href="/android-about-versions-in-chinese/android-4.3.html">Android 4.3 APIs</a></li><li><a href="/android-about-versions-in-chinese/android-4.2.html">Android 4.2 APIs</a></li><li><a href="/android-about-versions-in-chinese/android-4.1.html">Android 4.1 APIs</a></li></ul></li><li><a href="/android-about-versions-in-chinese/android.html">关于Android</a></li><li><a href="/android-about-versions-in-chinese/dashboards.html">数据表</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.android.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android&lt;/a&gt;每个版都会加入很多新功能，我们可以从官方文档&lt;a href=&quot;https://developer.android.com/about/versions/oreo/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Developers-&amp;gt;Home-&amp;gt;Android&lt;/a&gt;查看&lt;a href=&quot;https://www.android.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android&lt;/a&gt;每个版本更新的具体内容。本文是对&lt;a href=&quot;https://developer.android.com/about/versions/oreo/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Developers-&amp;gt;Home-&amp;gt;Android&lt;/a&gt;官方文档的中文翻译。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://feilongwang.org/tags/Android/"/>
    
      <category term="版本" scheme="https://feilongwang.org/tags/%E7%89%88%E6%9C%AC/"/>
    
      <category term="更新" scheme="https://feilongwang.org/tags/%E6%9B%B4%E6%96%B0/"/>
    
      <category term="文档" scheme="https://feilongwang.org/tags/%E6%96%87%E6%A1%A3/"/>
    
      <category term="翻译" scheme="https://feilongwang.org/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Git多项目管理</title>
    <link href="https://feilongwang.org/2016/08/29/Managing-Projects-Across-Git-Repositories/"/>
    <id>https://feilongwang.org/2016/08/29/Managing-Projects-Across-Git-Repositories/</id>
    <published>2016-08-29T15:15:23.000Z</published>
    <updated>2020-03-01T02:17:43.948Z</updated>
    
    <content type="html"><![CDATA[<p>开发中我们经常会遇到这样的情况：项目越来越大，一些通用的模块我们希望将他抽离出来作为单独的项目，以便其他项目也可以使用，或者使用一些第三方库，可能我们并不想将代码直接拷贝进我们的项目里面，而仅仅只是单纯的引用。这时问题来了，你想把他们当做独立的项目，同时又想在项目中使用另一个。<br><a id="more"></a></p><p>我们举一个例子。假设你正在使用<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>搭建自己的个人博客，然后使用了某个主题。<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>中的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>通常以独立项目的形式提供。如果直接将主题项目代码复制到博客项目中，不仅丢弃了主题项目的维护历史，同时你将再也无法自由及时地合并上游的更新。这时你就需要在个人博客项目中引用主题项目。</p><p>基于Git有多种方式来解决这个问题：<a href="#Git-Submodule">Git Submodule</a>，<a href="#Git-Subtree">Git Subtree</a>，<a href="#GitSlave">GitSlave</a>和<a href="#Google-Repo">Google Repo</a>。</p><h3 id="Git-Submodule"><a href="#Git-Submodule" class="headerlink" title="Git Submodule"></a>Git Submodule</h3><p>Git 1.5.3中加入了<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-submodule.html" target="_blank" rel="noopener">git submodule</a>这个命令。Git子模块允许你将一个Git仓库作为另一个Git仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持独立的提交。</p><h4 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h4><p>将一个已存在的Git仓库添加为正在工作的仓库的子模块，可以使用<code>git submodule add &lt;repository&gt; [&lt;path&gt;]</code>命令。以Hexo博客添加Hacker主题为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add /private/tmp/remote/Hacker.git themes/Hacker</span><br><span class="line">Cloning into &apos;/private/tmp/feilongwang.org/themes/Hacker&apos;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure></p><p>默认情况下，子模块会将子项目放在一个与仓库同名的目录中。我们也可以通过在命令结尾添加一个<code>path</code>来指定放到其他地方。</p><p>如果这时运行<code>git status</code>，你会注意到2件事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   .gitmodules</span><br><span class="line">new file:   themes/Hacker</span><br></pre></td></tr></table></figure></p><p>首先应当注意到新的<code>.gitmodules</code>文件。该文件保存了子模块的<code>url</code>与本地目录之间的映射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;themes/Hacker&quot;]</span><br><span class="line">path = themes/Hacker</span><br><span class="line">url = /private/tmp/remote/Hacker.git</span><br></pre></td></tr></table></figure></p><p>如果有多个子模块，该文件中就会有多条记录。</p><p>在<code>git status</code>输出中列出的另一个是项目文件夹记录。如果你运行<code>git diff</code>，会看到类似下面的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached themes/Hacker</span><br><span class="line">diff --git a/themes/Hacker b/themes/Hacker</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..98260cd</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/themes/Hacker</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit 98260cd27f0bb6340757cd05c3fb00d574b42d52</span><br></pre></td></tr></table></figure></p><p>虽然<code>themes/Hacker</code>是工作目录中的一个子目录，但Git将它视作一个子模块。当你不在那个目录中时，Git并不会跟踪他的内容，而是将它看作该仓库中的一个特殊提交。该特殊提交记录着父项目依赖的子模块的版本（子模块当前HEAD所指向的版本）。</p><blockquote><p>注意<code>themes/Hacker</code>记录的<code>160000</code>模式。这是Git中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p></blockquote><p>除了<code>git status</code>看到的差异外，还有个隐藏的变化在<code>.git/config</code>中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = true</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">ignorecase = true</span><br><span class="line">precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = /private/tmp/remote/feilongwang.org.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br><span class="line">[submodule &quot;themes/Hacker&quot;]</span><br><span class="line">url = /private/tmp/remote/Hacker.git</span><br></pre></td></tr></table></figure></p><p>父项目的<code>.git/config</code>文件中也保存了子模块的信息，所以你可以根据自己的需要，通过配置父项目<code>.git/config</code>文件来覆盖<code>.gitmodules</code>中的配置。如通过在本地执行<code>git config submodule.themes/Hacker.url &lt;url&gt;</code>来覆盖<code>.gitmodules</code>中的<code>url</code>。</p><h4 id="克隆子模块"><a href="#克隆子模块" class="headerlink" title="克隆子模块"></a>克隆子模块</h4><p>当你克隆一个含有子模块的项目时，默认会包含该子模块目录，但其中还没有任何文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">$ cd feilongwang.org/themes/Hacker/</span><br><span class="line">$ ls -al</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 wangfeilong wheel  68  9 19 03:01 ./</span><br><span class="line">drwxr-xr-x 4 wangfeilong wheel 136  9 19 03:01 ../</span><br></pre></td></tr></table></figure></p><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而<code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule &apos;themes/Hacker&apos; (/private/tmp/remote/Hacker.git) registered for path &apos;themes/Hacker&apos;</span><br><span class="line">$ git submodule update</span><br><span class="line">Cloning into &apos;/private/tmp/feilongwang.org/themes/Hacker&apos;...</span><br><span class="line">done.</span><br><span class="line">Submodule path &apos;themes/Hacker&apos;: checked out &apos;dc4a047cac6f26c47aba7bcd5b36f3ea7d3abf8b&apos;</span><br></pre></td></tr></table></figure></p><p>现在<code>themes/Hacker</code>就处在和之前提交时相同的状态。</p><p>不过还有更简单一点的方式。如果给<code>git clone</code>命令传递<code>--recursive</code>选项，它就会自动初始化并更新仓库中的每一个子模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">Submodule &apos;themes/Hacker&apos; (/private/tmp/remote/Hacker.git) registered for path &apos;themes/Hacker&apos;</span><br><span class="line">Cloning into &apos;/private/tmp/feilongwang.org/themes/Hacker&apos;...</span><br><span class="line">done.</span><br><span class="line">Submodule path &apos;themes/Hacker&apos;: checked out &apos;dc4a047cac6f26c47aba7bcd5b36f3ea7d3abf8b&apos;</span><br></pre></td></tr></table></figure></p><h4 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h4><p>假如在当前开发中，父项目只是使用子项目并不时的获取更新。这时你可以进入到子模块目录中运行<code>git fetch</code>与<code>git merge</code>，合并上游分支来更新本地代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &amp;&amp; git merge origin/master </span><br><span class="line">Updating dc4a047..76e18c4</span><br><span class="line">Fast-forward</span><br><span class="line"> layout/components/footer.ejs | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p><p>如果你不想在子模块目录中手动抓取与合并，那么还有种更容易的方式。运行<code>git submodule update --remote</code>，Git将会进入子模块然后抓取并更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (5/5), done.</span><br><span class="line">remote: Total 5 (delta 4), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (5/5), done.</span><br><span class="line">From /private/tmp/remote/Hacker</span><br><span class="line">   dc4a047..76e18c4  master     -&gt; origin/master</span><br><span class="line">Submodule path &apos;themes/Hacker&apos;: checked out &apos;76e18c4e5c915302fe2545f16c1df9350b33439f&apos;</span><br></pre></td></tr></table></figure></p><p>此命令默认会假定你想要更新并检出所有子模块仓库的master分支。不过你也可以指定想要更新的子模块、想要更新的分支以及更新后进行的操作。 </p><p>这时我们运行<code>git status</code>，Git会显示子模块中有“新提交”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   themes/Hacker (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p><p>如果在此时提交，那么你会将父项目锁定为子模块<code>master</code>分支最新的代码。</p><p>假如你希望在父项目上编写代码的同时又在子模块上编写代码，那又该如何处理呢？</p><p>当我们运行<code>git submodule update</code>从子模块仓库中抓取修改时，Git将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD”的状态。这意味着没有本地工作分支（例如 “master”）跟踪改动。所以你做的任何改动都不会被跟踪。</p><p>为了将子模块设置得更容易进入并修改，你应该进入每个必要的子模块并检出topic工作分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b featureA</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br></pre></td></tr></table></figure></p><p>然后，我们可以对子模块做些改动，使用<code>git fetch</code>或者<code>git pull</code>来更新代码，<code>git merge</code>或者<code>git rebase</code>合并改动，就像独立的项目开发一样。</p><p>当然，我们也可以在父项目中使用<code>git submodule update --remote --merge</code>或者<code>git submodule update --remote --rebase</code>来合并代码。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --rebase</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (5/5), done.</span><br><span class="line">remote: Total 5 (delta 4), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (5/5), done.</span><br><span class="line">From /private/tmp/remote/Hacker</span><br><span class="line">   98260cd..5eb6d18  master     -&gt; origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: Update README.md</span><br><span class="line">Submodule path &apos;themes/Hacker&apos;: rebased into &apos;5eb6d185e1efea4cd4bd48d046a6f8fb376b6836&apos;</span><br></pre></td></tr></table></figure></p><p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时Git会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p><p>如果你忘记<code>--rebase</code>或<code>--merge</code>，Git会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的HEAD状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">Submodule path &apos;themes/Hacker&apos;: checked out &apos;5eb6d185e1efea4cd4bd48d046a6f8fb376b6836&apos;</span><br></pre></td></tr></table></figure></p><p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基对应的分支（或任何一个你想要的远程分支）就行了。</p><p>如果你做了一些与上游改动冲突的改动，当运行更新时Git会让你知道，然后你可以进入子模块目录中然后就像平时那样修复冲突。</p><h4 id="提交子模块"><a href="#提交子模块" class="headerlink" title="提交子模块"></a>提交子模块</h4><p>如果我们在父项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。</p><p>提交子模块的改动最简单的选项是进入每一个子模块中然后手动推送到远程仓库。然而<code>git push</code>命令接受值为<code>on-demand</code>的<code>--recurse-submodules</code>参数，它会尝试为你这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=on-demand </span><br><span class="line">Pushing submodule &apos;themes/Hacker&apos;</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 344 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 2), reused 0 (delta 0)</span><br><span class="line">To /private/tmp/remote/Hacker.git</span><br><span class="line">   76e18c4..26fa290  master -&gt; master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 324 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">To /private/tmp/remote/feilongwang.org.git</span><br><span class="line">   3c7501e..fb39823  master -&gt; master</span><br></pre></td></tr></table></figure></p><h4 id="遍历子模块"><a href="#遍历子模块" class="headerlink" title="遍历子模块"></a>遍历子模块</h4><p>如果父项目中包含大量子模块，那我们一些通用的子模块操作，如更新子模块，将会变成巨大的工作量。幸好，Git提供了<code>foreach</code>子模块命令。</p><p>假如，我们想要开始开发一个新的功能或者修复一些错误，并且需要在几个子模块内工作。这时我们可能需要创建一个新的分支，然后将所有子模块都切换过去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach &apos;git checkout -b featureA&apos;</span><br><span class="line">Entering &apos;hexo-generator-feed&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br><span class="line">Entering &apos;themes/Hacker&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br></pre></td></tr></table></figure></p><h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>然而使用子模块还是有一些小问题：</p><ul><li>在父项目中<code>git pull</code>并不会自动更新子模块，需要调用<code>git submodule update</code>来更新子模块信息。如果忘记调用<code>git submodule update</code>，那么你极有可能再次把旧的子模块依赖信息提交上去。</li><li>调用<code>git submodule update</code>并不会将子模块切换到任何分支，默认情况下子模块处于“游离的 HEAD”的状态。如果此时我们改动子模块而没有检出一个工作分支，那调用<code>git submodule update</code>时你所做的任何改动都会丢失。</li><li>Git子模块在父项目中维护所有依赖的子模块版本，当包含大量子模块时，父项目的更新将很容发生冲突，并且父项目的维护历史与所有子模块的维护历史相互交织，维护成本也会比较高。</li></ul><h3 id="Git-Subtree"><a href="#Git-Subtree" class="headerlink" title="Git Subtree"></a>Git Subtree</h3><p>Git在1.8.0版本引入了<a href="https://git.kernel.org/pub/scm/git/git.git/plain/contrib/subtree/git-subtree.txt" target="_blank" rel="noopener">git subtree</a>这个命令，它使用Git的<code>subtree merge</code>策略来得到类似<code>git submodule</code>的结果。但本质上，它是将子项目的代码全部<code>merge</code>进父项目。使用<a href="https://git.kernel.org/pub/scm/git/git.git/plain/contrib/subtree/git-subtree.txt" target="_blank" rel="noopener">git subtree</a>，你不仅可以将其他项目合并为父项目的一个子目录，而且可以从父项目提取某个子目录的全部历史作为一个单独的项目。</p><h4 id="相比Git子模块"><a href="#相比Git子模块" class="headerlink" title="相比Git子模块"></a>相比Git子模块</h4><ul><li>管理和更新流程比较方便</li><li>不再有<code>.gitmodules</code>文件</li><li>克隆仓库不再需要<code>init</code>和<code>update</code>等操作</li><li>删除时不再像<code>git submodule</code>那样费劲</li></ul><h4 id="添加子项目"><a href="#添加子项目" class="headerlink" title="添加子项目"></a>添加子项目</h4><p>将一个已存在的Git仓库以Subtree方式添加为子项目可以使用<code>git subtree add --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</code>命令，其中<code>--prefix</code>选项指定了子项目对应的子目录，<code>--squash</code>选项用以压缩Subtree的提交为一个，这样父项目的历史记录里就不会出现子项目完整的历史记录。我们还是以Hexo博客添加Hacker主题为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">$ cd feilongwang.org/</span><br><span class="line">$ git subtree add --prefix=themes/Hacker /private/tmp/remote/Hacker.git master --squash </span><br><span class="line">git fetch /private/tmp/remote/Hacker.git master</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 216, done.</span><br><span class="line">remote: Compressing objects: 100% (143/143), done.</span><br><span class="line">remote: Total 216 (delta 70), reused 216 (delta 70)</span><br><span class="line">Receiving objects: 100% (216/216), 56.22 KiB | 0 bytes/s, done.</span><br><span class="line">Resolving deltas: 100% (70/70), done.</span><br><span class="line">From /private/tmp/remote/Hacker</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Added dir &apos;themes/Hacker&apos;</span><br></pre></td></tr></table></figure></p><h4 id="更新子项目"><a href="#更新子项目" class="headerlink" title="更新子项目"></a>更新子项目</h4><p>一段时间之后，子项目可能有大量新的代码，父项目也想使用这些代码。此时父项目的维护者只需执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git subtree pull --prefix=themes/Hacker /private/tmp/remote/Hacker.git master --squash </span><br><span class="line">remote: Counting objects: 8, done.</span><br><span class="line">remote: Compressing objects: 100% (8/8), done.</span><br><span class="line">remote: Total 8 (delta 6), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (8/8), done.</span><br><span class="line">From /private/tmp/remote/Hacker</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> themes/Hacker/README.md                    | 2 +-</span><br><span class="line"> themes/Hacker/layout/components/footer.ejs | 3 ++-</span><br><span class="line"> 2 files changed, 3 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure></p><p>就可以将父项目中子项目对应目录里的内容更新为子项目最新的代码了。</p><p>如果你觉得每次都输入子项目完整的仓库url太麻烦，你也可以将子项目添加为追踪的仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add hacker /private/tmp/remote/Hacker.git</span><br><span class="line">$ git subtree add --prefix=themes/Hacker hacker master --squash</span><br><span class="line">git fetch hacker master</span><br><span class="line">From /private/tmp/remote/Hacker</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; hacker/master</span><br><span class="line">Added dir &apos;themes/Hacker&apos;</span><br></pre></td></tr></table></figure></p><h4 id="提取子项目"><a href="#提取子项目" class="headerlink" title="提取子项目"></a>提取子项目</h4><p>当我们开发一个项目若干时间后，希望将某个目录单独出一个项目来开发，同时又保留这部分代码历史提交记录，使用<code>git subtree split</code>可以很轻松的完成这个操作。以Hexo博客分离Hacker主题为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git subtree split --prefix=themes/Hacker --branch hacker</span><br><span class="line">Created branch &apos;hacker&apos;</span><br><span class="line">843147f3181399b06528251451bc498e01425f34</span><br><span class="line">$ git branch -a</span><br><span class="line">  hacker</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br><span class="line">$ git checkout hacker </span><br><span class="line">Switched to branch &apos;hacker&apos;</span><br><span class="line">$ git log</span><br><span class="line">commit 843147f3181399b06528251451bc498e01425f34</span><br><span class="line">Author: Feilong Wang &lt;i@feilongwang.org&gt;</span><br><span class="line">Date:   Mon Sep 19 01:16:02 2016 +0800</span><br><span class="line"></span><br><span class="line">    Change theme to Hacker</span><br></pre></td></tr></table></figure></p><p>其中<code>--branch</code>指定将生成的历史提交记录保存到一个新的分支。</p><h4 id="提交子项目"><a href="#提交子项目" class="headerlink" title="提交子项目"></a>提交子项目</h4><p>如果我们在使用子项目的过程中，对子项目做了一些改动，同时我们又希望子项目的其他使用者也能共享这些改动，此时可以将我们的改动提交到子项目的远程仓库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git subtree push --prefix=themes/Hacker /private/tmp/remote/Hacker.git master</span><br><span class="line">git push using:  /private/tmp/remote/Hacker.git master</span><br><span class="line">Counting objects: 301, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (211/211), done.</span><br><span class="line">Writing objects: 100% (301/301), 579.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 301 (delta 67), reused 292 (delta 64)</span><br><span class="line">remote: Resolving deltas: 100% (67/67), completed with 2 local objects.</span><br><span class="line">To /private/tmp/remote/Hacker.git</span><br><span class="line">   96ca04b..5565513  556551375034489fc8710070a29a2f22240a39b3 -&gt; master</span><br></pre></td></tr></table></figure></p><h3 id="GitSlave"><a href="#GitSlave" class="headerlink" title="GitSlave"></a>GitSlave</h3><p>GitSlave用于管理相关的一个父项目和多个Slave项目。通常，它会将你要执行的Git常规操作顺序在父项目和Slave项目中执行一遍，所以当你执行pull操作，项目中的所有仓库会顺序执行pull操作。GitSlave是对Git命令的封装，是被设计用于简化多仓库的Git操作，而不是要取代Git。我们还是以Hexo博客项目和Hacker主题项目为例来说明GitSlave的用法。</p><h4 id="添加Slave项目"><a href="#添加Slave项目" class="headerlink" title="添加Slave项目"></a>添加Slave项目</h4><p>我们可以通过<code>gits prepare</code>初始化父项目，然后通过<code>gits attach</code>命令来添加Slave项目。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">$ cd feilongwang.org</span><br><span class="line">$ gits prepare</span><br><span class="line">[master 211dc36] gits creating .gitslave</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitslave</span><br><span class="line">$ cat .gitslave</span><br></pre></td></tr></table></figure></p><p>可以看出，当执行<code>gits prepare</code>命令时，它会在父项目的根目录下添加一个空的<code>.gitslave</code>文件。然后我们可以执行<code>gits attach REPOSITORY LOCALPATH</code>来添加Slave项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gits attach ../Hacker.git themes/Hacker</span><br><span class="line">Cloning into &apos;themes/Hacker&apos;...</span><br><span class="line">done.</span><br><span class="line">[master 2e059b2] gits adding &quot;../Hacker.git&quot; &quot;themes/Hacker&quot;</span><br><span class="line">$ git show</span><br><span class="line">diff --git a/.gitignore b/.gitignore</span><br><span class="line">index cd1fbcc..401d29a 100644</span><br><span class="line">--- a/.gitignore</span><br><span class="line">+++ b/.gitignore</span><br><span class="line">@@ -5,3 +5,4 @@ db.json</span><br><span class="line"> node_modules/</span><br><span class="line"> public/</span><br><span class="line"> .deploy*/</span><br><span class="line">+/themes/Hacker/</span><br><span class="line">diff --git a/.gitslave b/.gitslave</span><br><span class="line">index e69de29..3b17767 100644</span><br><span class="line">--- a/.gitslave</span><br><span class="line">+++ b/.gitslave</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+&quot;../Hacker.git&quot; &quot;themes/Hacker&quot;</span><br></pre></td></tr></table></figure></p><h4 id="克隆带有Slave仓库的项目"><a href="#克隆带有Slave仓库的项目" class="headerlink" title="克隆带有Slave仓库的项目"></a>克隆带有Slave仓库的项目</h4><p>我们可以使用<code>gits clone</code>来克隆带有Slave仓库的项目，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gits clone /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">Cloning into &apos;themes/Hacker&apos;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure></p><p>我们看到Git的克隆操作顺序在父项目与子项目中被执行。</p><p>如果一开始你并知道要克隆的项目带有Slave仓库而直接将父项目克隆下来，此时我们可以通过<code>git populate</code>来进一步克隆Slave仓库，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /private/tmp/remote/feilongwang.org.git</span><br><span class="line">Cloning into &apos;feilongwang.org&apos;...</span><br><span class="line">done.</span><br><span class="line">$ cd feilongwang.org/</span><br><span class="line">$ ls -al</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 10 wangfeilong wheel  340 10 30 16:43 ./</span><br><span class="line">drwxr-xr-x  3 wangfeilong wheel  102 10 30 16:43 ../</span><br><span class="line">drwxr-xr-x 12 wangfeilong wheel  408 10 30 16:43 .git/</span><br><span class="line">-rw-r--r--  1 wangfeilong wheel   82 10 30 16:43 .gitignore</span><br><span class="line">-rw-r--r--  1 wangfeilong wheel   32 10 30 16:43 .gitslave</span><br><span class="line">-rw-r--r--  1 wangfeilong wheel  540 10 30 16:43 README.md</span><br><span class="line">-rw-r--r--  1 wangfeilong wheel 1599 10 30 16:43 _config.yml</span><br><span class="line">-rw-r--r--  1 wangfeilong wheel  630 10 30 16:43 package.json</span><br><span class="line">drwxr-xr-x  5 wangfeilong wheel  170 10 30 16:43 scaffolds/</span><br><span class="line">drwxr-xr-x  6 wangfeilong wheel  204 10 30 16:43 source/</span><br></pre></td></tr></table></figure><p>此时我们发现子项目并没有被克隆。执行<code>gits populate</code>将克隆所有子项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gits populate</span><br><span class="line">Cloning into &apos;themes/Hacker&apos;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure></p><h4 id="提交项目"><a href="#提交项目" class="headerlink" title="提交项目"></a>提交项目</h4><p>我们对父项目和子项目做些修改、提交并将这些改动push到服务端，只需将对应的<code>git</code>命令换成<code>gits</code>，它会顺序在所有仓库中执行对应的<code>git</code>命令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ echo “*.iml&quot; &gt;&gt; .gitignore</span><br><span class="line">$ echo “*.iml&quot; &gt;&gt; themes/Hacker/.gitignore</span><br><span class="line">$ $ gits add -A</span><br><span class="line">$ gits commit -m &quot;Ignore *.iml&quot;</span><br><span class="line">On: (feilongwang.org):</span><br><span class="line">  [master a2ff2d7] Ignore *.iml</span><br><span class="line">   1 file changed, 1 insertion(+)</span><br><span class="line">On: themes/Hacker:</span><br><span class="line">  [master 03dfa7b] Ignore *.iml</span><br><span class="line">   1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ gits push</span><br><span class="line">On: (feilongwang.org):</span><br><span class="line">  To /private/tmp/remote/feilongwang.org.git</span><br><span class="line">     2e059b2..a2ff2d7  master -&gt; master</span><br><span class="line">On: themes/Hacker:</span><br><span class="line">  To /private/tmp/remote/Hacker.git</span><br><span class="line">     dc4a047..03dfa7b  master -&gt; master</span><br></pre></td></tr></table></figure></p><h4 id="更新项目"><a href="#更新项目" class="headerlink" title="更新项目"></a>更新项目</h4><p>如果你想更新服务端最新代码，可以使用<code>gits pull</code>命令，它会将所有仓库代码都同步为服务端最新状态，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gits pull</span><br><span class="line">On: (feilongwang.org):</span><br><span class="line">  Already up-to-date.</span><br><span class="line">On: themes/Hacker:</span><br><span class="line">  From /private/tmp/remote/%REPO%</span><br><span class="line">    master     -&gt; origin/master</span><br><span class="line">  Fast-forward</span><br><span class="line">   .gitignore | 1 +</span><br><span class="line">   1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>从上面的命令可以看出，GitSlave是对Git命令的封装，它可以简化多项目的Git操作。</p><h4 id="GitSlave的缺点"><a href="#GitSlave的缺点" class="headerlink" title="GitSlave的缺点"></a>GitSlave的缺点</h4><p>GitSlave被设计用于包含多个Slave仓库的中等大小项目的开发，其在父项目的<code>.gitslave</code>文件中记录所需子项目的信息，并在所有仓库中顺序执行相应Git操作的设计原理，注定其使用场景有一定局限性。</p><ul><li>GitSlave并不会记录所需子项目的版本，所以其永远只是追踪子项目的最新版本，无法满足父项目基于某一特定版本子项目的场景，而此种场景在开发中却是极为常见。</li><li>GitSlave在父项目的<code>.gitslave</code>文件中记录相关子项目的信息，使得父项目本身的提交历史与子项目的增删历史相互交织在一起，一旦子项目增多，父项目的提交历史将变得混乱。</li></ul><h3 id="Google-Repo"><a href="#Google-Repo" class="headerlink" title="Google Repo"></a>Google Repo</h3><p>到此，我们可以总结出，一个优秀的基于Git的多项目管理系统设计需要满足如下2点：</p><ol><li>记录子项目的远程地址、所需版本和对应的本地路径。</li><li>这个记录文件应该单独维护，而不应该污染任何一个仓库，因为它与这些仓库本身毫无关系。</li></ol><p>Google Repo正是完美匹配这2个设计要点的Git多项目管理系统。</p><p><a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">Repo</a>是Google为了有效组织<a href="https://www.android.com" target="_blank" rel="noopener">Android</a>的源代码而开发的一个基于Git的管理工具。<a href="https://source.android.com" target="_blank" rel="noopener">Android开放源码项目（AOSP）</a>由几百个子项目组成（最新Android 7.0的源代码包含520多个子项目），每个子项目又有很多的分支版本，为了有效的管理这些子项目，需要一个自动化管理工具，Repo应运而生。</p><p><a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">Repo</a>工具实际上是由一系列<a href="https://www.python.org/" target="_blank" rel="noopener">Python</a>脚本组成，这些Python脚本通过调用Git命令来完成自己的功能。比较有意思的是，组成Repo工具的那些Python脚本本身也是一个Git仓库。这个Git仓库被称为Repo仓库。我们每次执行Repo命令的时候，Repo仓库都会对自己进行一次更新。</p><p>从之前的结论我们知道，一个优秀的基于Git的多项目管理系统会有一个单独的清单文件记录所有子项目的元信息（子项目的远程地址、所需版本和对应的本地路径）。在<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">Repo</a>管理系统中，这个清单文件单独存在于一个Git仓库，被称为Menifest仓库。Menifest仓库的版本对应着整个项目不同的版本。</p><p>到目前为止，我们知道<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">Repo</a>管理系统中存在着3种类型的Git仓库，分别是Repo仓库、Manifest仓库以及所有子项目仓库。Repo仓库通过Menifest仓库可以获取所有子项目的元信息。有了这些元信息后，就可以通过Repo仓库里面的Python脚本来操作所有的子项目了。那么，Repo仓库和Manifest仓库又是怎么来的呢？答案是通过一个独立的Repo脚本来获取，这个Repo脚本位于<a href="https://source.android.com" target="_blank" rel="noopener">AOSP（Android Open Source Project）</a>的官方网站上，我们可以通过HTTP协议来下载。</p><p>我们以<a href="https://source.android.com" target="_blank" rel="noopener">AOSP</a>项目为例说明Repo的用法。</p><h4 id="安装Repo"><a href="#安装Repo" class="headerlink" title="安装Repo"></a>安装Repo</h4><p>在你的用户主目录下创建bin目录，并且添加bin目录到的你的PATH中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/bin</span><br><span class="line">$ PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>下载Repo脚本到bin目录，并确保它可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">$ chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p><p>查看Repo脚本的内容，我们可以看到Repo仓库的地址和版本。Repo脚本执行<code>init</code>命令时会从该地址下载Repo仓库并切换到指定的分支。以后执行其他Repo命令，Repo脚本都会自动更新Repo仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/bin/repo</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line"># repo default configuration</span><br><span class="line">#</span><br><span class="line">import os</span><br><span class="line">REPO_URL = os.environ.get(&apos;REPO_URL&apos;, None)</span><br><span class="line">if not REPO_URL:</span><br><span class="line">  REPO_URL = &apos;https://gerrit.googlesource.com/git-repo&apos;</span><br><span class="line">REPO_REV = &apos;stable&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="初始化Repo用户端"><a href="#初始化Repo用户端" class="headerlink" title="初始化Repo用户端"></a>初始化Repo用户端</h4><p>创建工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir android</span><br><span class="line">$ cd android</span><br></pre></td></tr></table></figure></p><p>根据实际情况配置Git，该信息会将会出现在Git项目的提交信息中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Feilong Wang“</span><br><span class="line">$ git config --global user.email “i@feilongwang.org”</span><br></pre></td></tr></table></figure></p><p>运行<code>repo init -u url [options]</code>初始化Repo用户端。其中url指定Menifest仓库的地址。默认情况下，<code>repo init</code>会下载Repo仓库，切换到Repo脚本中<code>REPO_REV</code>指定的分支，并下载Menifest仓库，切换到master分支。你也通过加上<code>-b</code>参数来指定Manifest的分支或版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure></p><p>Repo用户端初始化成功后，当前目录下将会有个<code>.repo</code>目录，里面包含Repo仓库和Manifest仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 3 wangfeilong staff 102 11 13 21:03 ./</span><br><span class="line">drwxr-xr-x 8 wangfeilong staff 442 10  9 15:28 ../</span><br><span class="line">drwxr-xr-x 3 wangfeilong staff 102 11 13 21:00 .repo/</span><br><span class="line">$ cd .repo/</span><br><span class="line">$ ls -al</span><br><span class="line">total 44</span><br><span class="line">drwxr-xr-x  7 wangfeilong staff   340  9 16 09:33 ./</span><br><span class="line">drwxr-xr-x 29 wangfeilong staff  1224 10 20 10:51 ../</span><br><span class="line">-rw-r--r--  1 wangfeilong staff 28439 10  8 16:58 .repo_fetchtimes.json</span><br><span class="line">lrwxr-xr-x  1 wangfeilong staff    21  4  4  2016 manifest.xml -&gt; manifests/default.xml</span><br><span class="line">drwxr-xr-x  3 wangfeilong staff   170 11  1 22:20 manifests/</span><br><span class="line">drwxr-xr-x  9 wangfeilong staff   510  3 16  2016 manifests.git/</span><br><span class="line">drwxr-xr-x  6 wangfeilong staff   204  3 16  2016 project-objects/</span><br><span class="line">-rw-r--r--  1 wangfeilong staff 11105 10  8 16:58 project.list</span><br><span class="line">drwxr-xr-x 28 wangfeilong staff   952  4  5  2016 projects/</span><br><span class="line">drwxr-xr-x  7 wangfeilong staff  1700 10  8 16:58 repo/</span><br></pre></td></tr></table></figure></p><p>可以看到Manifest清单文件内容如下，<code>remote</code>标签指定了子项目仓库的地址前缀，<code>project</code>标签指定了子项目仓库的相对地址和本地路径，<code>revision</code>属性指定子项目的分支或版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat manifest.xml </span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line"></span><br><span class="line">  &lt;remote  name=&quot;aosp&quot;</span><br><span class="line">           fetch=&quot;..&quot;</span><br><span class="line">           review=&quot;https://android-review.googlesource.com/&quot; /&gt;</span><br><span class="line">  &lt;default revision=&quot;master&quot;</span><br><span class="line">           remote=&quot;aosp&quot;</span><br><span class="line">           sync-j=&quot;4&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;project path=&quot;build&quot; name=&quot;platform/build&quot; groups=&quot;pdk&quot; &gt;</span><br><span class="line">    &lt;copyfile src=&quot;core/root.mk&quot; dest=&quot;Makefile&quot; /&gt;</span><br><span class="line">  &lt;/project&gt;</span><br><span class="line">  &lt;project path=&quot;build/blueprint&quot; name=&quot;platform/build/blueprint&quot; groups=&quot;pdk,tradefed&quot; /&gt;</span><br><span class="line">  &lt;project path=&quot;build/kati&quot; name=&quot;platform/build/kati&quot; groups=&quot;pdk,tradefed&quot; /&gt;</span><br><span class="line">  &lt;project path=&quot;build/soong&quot; name=&quot;platform/build/soong&quot; groups=&quot;pdk,tradefed&quot; &gt;</span><br><span class="line">    &lt;linkfile src=&quot;root.bp&quot; dest=&quot;Android.bp&quot; /&gt;</span><br><span class="line">    &lt;linkfile src=&quot;bootstrap.bash&quot; dest=&quot;bootstrap.bash&quot; /&gt;</span><br><span class="line">  &lt;/project&gt;</span><br><span class="line">  &lt;project path=&quot;art&quot; name=&quot;platform/art&quot; groups=&quot;pdk&quot; /&gt;</span><br><span class="line">  &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; groups=&quot;pdk&quot; /&gt;</span><br><span class="line">  &lt;project path=&quot;bootable/recovery&quot; name=&quot;platform/bootable/recovery&quot; groups=&quot;pdk&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="下载所有子项目代码"><a href="#下载所有子项目代码" class="headerlink" title="下载所有子项目代码"></a>下载所有子项目代码</h4><p>现在，我们可以通过执行<code>repo sync</code>来下载所有项目的源代码了。以后如果服务端有更新，我们也可以通过此命令来获取更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo sync</span><br></pre></td></tr></table></figure></p><h4 id="提交项目-1"><a href="#提交项目-1" class="headerlink" title="提交项目"></a>提交项目</h4><p>由于Repo管理系统中每一个子项目都是单独的Git仓库，所以我们在某一个仓库进行开发时，完全可以使用原先单个Git仓库的开发方式，可以使用<code>git pull</code>，<code>git rebase</code>等命令。只是在同时操作多个子项目时，我们可以使用Repo分装好的批处理命令，如<code>repo start</code>在所有子项目中创建一个新的topic分支。更多Repo命令请运行<code>repo help</code>查看，在此不再赘述。</p><hr><p>参考</p><ul><li><a href="http://blog.devtang.com/2013/05/08/git-submodule-issues/" target="_blank" rel="noopener">http://blog.devtang.com/2013/05/08/git-submodule-issues/</a></li><li><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="noopener">http://www.kafeitu.me/git/2012/03/27/git-submodule.html</a></li><li><a href="http://blog.chh.tw/posts/git-submodule/" target="_blank" rel="noopener">http://blog.chh.tw/posts/git-submodule/</a></li><li><a href="http://efe.baidu.com/blog/git-submodule-vs-git-subtree/" target="_blank" rel="noopener">http://efe.baidu.com/blog/git-submodule-vs-git-subtree/</a></li><li><a href="http://aoxuis.me/post/2013-08-06-git-subtree" target="_blank" rel="noopener">http://aoxuis.me/post/2013-08-06-git-subtree</a></li><li><a href="http://www.tuicool.com/articles/veaEBr" target="_blank" rel="noopener">http://www.tuicool.com/articles/veaEBr</a></li><li><a href="http://gitslave.sourceforge.net/" target="_blank" rel="noopener">http://gitslave.sourceforge.net/</a></li><li><a href="http://gitslave.sourceforge.net/tutorial-basic.html" target="_blank" rel="noopener">http://gitslave.sourceforge.net/tutorial-basic.html</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/18195205" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/18195205</a></li><li><a href="https://git.kernel.org/pub/scm/git/git.git/plain/contrib/subtree/git-subtree.txt" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/git/git.git/plain/contrib/subtree/git-subtree.txt</a></li><li><a href="https://segmentfault.com/a/1190000003076028" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003076028</a></li><li><a href="https://gist.github.com/kvnsmth/4688345" target="_blank" rel="noopener">https://gist.github.com/kvnsmth/4688345</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97</a></li><li><a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">https://source.android.com/source/using-repo.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中我们经常会遇到这样的情况：项目越来越大，一些通用的模块我们希望将他抽离出来作为单独的项目，以便其他项目也可以使用，或者使用一些第三方库，可能我们并不想将代码直接拷贝进我们的项目里面，而仅仅只是单纯的引用。这时问题来了，你想把他们当做独立的项目，同时又想在项目中使用另一个。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Git" scheme="https://feilongwang.org/tags/Git/"/>
    
      <category term="项目" scheme="https://feilongwang.org/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Learning Gradle</title>
    <link href="https://feilongwang.org/2016/07/23/Learning-Gradle/"/>
    <id>https://feilongwang.org/2016/07/23/Learning-Gradle/</id>
    <published>2016-07-23T14:40:29.000Z</published>
    <updated>2020-03-08T09:02:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>作为Android应用开发的官方IDE，默认使用<a href="https://www.gradle.org/" target="_blank" rel="noopener">Gradle</a>作为构建工具，所以对于<a href="https://developer.android.com" target="_blank" rel="noopener">Android应用开发</a>来说，Gradle是必须要掌握的工具。然而现实是，很多Android应用开发人员都不太了解Gradle，并且网上大部分关于<a href="https://developer.android.com/studio/releases/gradle-plugin.html" target="_blank" rel="noopener">Android Gradle</a>的资料都是帮助解决某个具体的配置问题，缺乏系统深入的讲解。本文就来系统且深入的学习<a href="https://www.gradle.org/" target="_blank" rel="noopener">Gradle</a>。<br><a id="more"></a></p><h3 id="Java构建工具的发展"><a href="#Java构建工具的发展" class="headerlink" title="Java构建工具的发展"></a>Java构建工具的发展</h3><p>Java构建工具最早出现的是<a href="http://ant.apache.org/" target="_blank" rel="noopener">Ant</a>。Ant里的每一个任务（target）都可以互相依赖。Ant的最大缺点就是依赖的外部库也要添加到版本控制系统中，因为Ant没有一个机制来把这些外部库文件放在一个中央库里面，结果就是不断的拷贝和粘贴代码。</p><p>随后<a href="https://maven.apache.org" target="_blank" rel="noopener">Maven</a>在2004年出现了，Maven引入了标准的项目和路径结构，还有依赖管理，不幸的是自定义的逻辑很难实现，唯一的方法就是引入插件。</p><p>随后Ant通过<a href="http://ant.apache.org/ivy/" target="_blank" rel="noopener">Apache Ivy</a>引入依赖管理来跟上Maven的脚步，Ant和Ivy集成实现了声明式的依赖，比如项目的编译和打包过程。</p><p><a href="https://www.gradle.org/" target="_blank" rel="noopener">Gradle</a>的出现满足了很多现在构建工具的需求，Gradle提供了一个<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL（领域特定语言）</a>，一个约定优于配置的方法，还有更强大的依赖管理，Gradle使得我们可以抛弃XML的繁琐配置，引入动态语言<a href="http://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a>来定义你的构建逻辑。</p><h3 id="Why-Gradle"><a href="#Why-Gradle" class="headerlink" title="Why Gradle"></a>Why Gradle</h3><p><a href="http://tools.android.com/" target="_blank" rel="noopener">Android Studio Project Site</a>上对Android Studio为何选用Gradle作为构建工具描述如下：</p><p>Gradle is an advanced build system as well as an advanced build toolkit allowing to create custom build logic through plugins. Here are some of its features that made us choose Gradle:</p><ul><li>Domain Specific Language (DSL) based on Groovy, used to describe and manipulate the build logic</li><li>Build files are Groovy based and allow mixing of declarative elements through the DSL and using code to manipulate the DSL elements to provide custom logic.</li><li>Built-in dependency management through Maven and/or Ivy.</li><li>Very flexible. Allows using best practices but doesn’t force its own way of doing things.</li><li>Plugins can expose their own DSL and their own API for build files to use.</li><li>Good Tooling API allowing IDE integration.</li></ul><p>DSL，领域特定语言，指不像通用目的语言那样目标范围涵盖一切软件问题，而是专门针对某一特定问题的计算机语言，如init.rc，renderscript等。</p><h3 id="理解Groovy"><a href="#理解Groovy" class="headerlink" title="理解Groovy"></a>理解Groovy</h3><p>由于Gradle是基于<a href="http://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a>开发的，要深入理解Gradle，必须先了解Groovy。Groovy概括的说就是把写Java程序变得像写脚本一样简单，写完就可以执行，Groovy内部会将其编译成Java字节码，然后启动虚拟机来执行。Groovy是用于Java虚拟机，具有像<a href="https://www.python.org/" target="_blank" rel="noopener">Python</a>，<a href="https://www.ruby-lang.org/" target="_blank" rel="noopener">Ruby</a>和<a href="http://www.smalltalk.org/" target="_blank" rel="noopener">Smalltalk</a>语言特性的敏捷的动态语言，使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。Groovy使用方式基本与Java代码的使用方式相同，其设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。</p><h4 id="Groovy安装"><a href="#Groovy安装" class="headerlink" title="Groovy安装"></a>Groovy安装</h4><p>Mac上可以直接通过<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>安装Groovy，具体命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install groovy</span><br></pre></td></tr></table></figure></p><p>安装完成后可通过如下命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groovy -v</span><br><span class="line">Groovy Version: 2.4.8 JVM: 1.8.0_45 Vendor: Oracle Corporation OS: Mac OS X</span><br></pre></td></tr></table></figure></p><h4 id="Groovy基础语法"><a href="#Groovy基础语法" class="headerlink" title="Groovy基础语法"></a>Groovy基础语法</h4><ul><li>可以不同分号结尾。</li><li>支持动态类型，即定义变量时可以不指定其类型。</li><li>可以使用关键字def定义变量和函数（Groovy推荐）（其实def会改变变量的作用域）。</li><li>Groovy中的所有事物都是对象。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> var = <span class="string">"Hello Groovy"</span></span><br><span class="line">println var</span><br><span class="line">println var.<span class="keyword">class</span></span><br><span class="line"></span><br><span class="line">var = <span class="number">5</span></span><br><span class="line">println var</span><br><span class="line">println var.<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello Groovy</span><br><span class="line">class java.lang.String</span><br><span class="line">5</span><br><span class="line">class java.lang.Integer</span><br></pre></td></tr></table></figure></p><ul><li>单引号中的内容严格对应Java的String，不对$进行转义。</li><li>双引号的内容如果有$则会对$表达式先求值（<a href="http://groovy-lang.org/api.html" target="_blank" rel="noopener">GString</a>）。</li><li>三引号可以指示一个多行的字符串，并可以在其中自由的使用单引号和双引号。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name = <span class="string">'Jerry'</span></span><br><span class="line">println <span class="string">'His name is $name'</span></span><br><span class="line">println <span class="string">"His name is $name"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> members = <span class="string">"""</span></span><br><span class="line"><span class="string">    'Terry'</span></span><br><span class="line"><span class="string">    "Larry" """</span></span><br><span class="line">println <span class="string">"Team member is: "</span> + members</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">His name is $name</span><br><span class="line">His name is Jerry</span><br><span class="line">Team member is:</span><br><span class="line">    &apos;Terry&apos;</span><br><span class="line">    &quot;Larry&quot;</span><br></pre></td></tr></table></figure></p><ul><li>函数定义时返回值和函数参数也可以不指定类型。</li><li>未指定返回类型的函数定义必须使用def。</li><li>可以不使用return xxx来设置函数返回值，函数最后一行代码的执行结果被设置成返回值，如果定义时指明了类型则必须返回正确的数据类型。</li><li>函数调用可以不加括号，构造函数和无参函数除外。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> getValue(name) &#123;<span class="comment">// def is must</span></span><br><span class="line">    name + <span class="string">"'s value is 10"</span></span><br><span class="line">&#125;</span><br><span class="line">value = getValue <span class="string">"Terry"</span></span><br><span class="line">println value</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terry<span class="string">'s value is 10</span></span><br></pre></td></tr></table></figure></p><ul><li>Java原始数据类型在Groovy中为其对应的包装类型。</li><li>类不支持default作用域，且默认作用域为public，如果需要public修饰符，则不用写它。</li><li>自动提供足够使用的构造函数（一个无参和带一个Map参数的构造函数，足够）。</li><li>Groovy动态的为每一个字段都会自动生成getter和setter，并且我们可以通过像访问字段本身一样调用getter和setter。</li><li>Groovy所有的对象都有一个元类<code>metaClass</code>，我们可以通过metaClass属性访问该元类。通过元类，可以为这个对象增加属性和方法（在java中不可想象）！</li><li>常用的集合类有<code>List</code>，<code>Map</code>，<code>Range</code>。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id</span><br><span class="line">    String name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setId(id) &#123;</span><br><span class="line">        println <span class="string">"setId($id)"</span></span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="string">"id=$id, name=$name"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">merry = <span class="keyword">new</span> Person()</span><br><span class="line">merry.id = <span class="number">1</span>    <span class="comment">// call merry.setId(1)</span></span><br><span class="line">merry.setName <span class="string">"Merry"</span></span><br><span class="line">println merry</span><br><span class="line">println merry.getId().<span class="keyword">class</span></span><br><span class="line">jerry = <span class="keyword">new</span> Person(<span class="string">id:</span> <span class="number">2</span>, <span class="string">name:</span> <span class="string">"Jerry"</span>)</span><br><span class="line">println jerry</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setId(1)</span><br><span class="line">id=1, name=Merry</span><br><span class="line">class java.lang.Integer</span><br><span class="line">setId(2)</span><br><span class="line">id=2, name=Jerry</span><br></pre></td></tr></table></figure></p><p>下面的例子展示通过metaClass向String对象中动态添加属性和方法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> msg = <span class="string">"Hello Groovy"</span></span><br><span class="line">msg.metaClass.upper = &#123; delegate.toUpperCase() &#125;</span><br><span class="line">msg.metaClass.lower = msg.toLowerCase()</span><br><span class="line">println msg.upper()</span><br><span class="line">println msg.lower</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO GROOVY</span><br><span class="line">hello groovy</span><br></pre></td></tr></table></figure></p><h4 id="Groovy动态性"><a href="#Groovy动态性" class="headerlink" title="Groovy动态性"></a>Groovy动态性</h4><p>Groovy动态性示例如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> bark() &#123;</span><br><span class="line">       println <span class="string">'woof!'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> sit() &#123;</span><br><span class="line">       println <span class="string">'sitting!'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> jump() &#123;</span><br><span class="line">       println <span class="string">'boing!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="keyword">def</span> acts = [<span class="string">'sit'</span>,<span class="string">'jump'</span>,<span class="string">'bark'</span>]</span><br><span class="line">acts.each &#123;</span><br><span class="line">    dog.<span class="string">"$&#123;it&#125;"</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sitting!</span><br><span class="line">boing!</span><br><span class="line">woof!</span><br></pre></td></tr></table></figure></p><p>另一个动态性的例子：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">def</span> doing()</span><br><span class="line">    &#123;</span><br><span class="line">       println <span class="string">'Ligth turning on...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOff</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">def</span> doing()</span><br><span class="line">    &#123;</span><br><span class="line">       println <span class="string">'Ligth turning off...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">def</span> control(action)</span><br><span class="line">    &#123;</span><br><span class="line">       action.<span class="string">"doing"</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> sh = <span class="keyword">new</span> Switch()</span><br><span class="line">sh.control(<span class="keyword">new</span> LightOn())</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ligth turning on...</span><br></pre></td></tr></table></figure></p><h4 id="Groovy-List"><a href="#Groovy-List" class="headerlink" title="Groovy List"></a>Groovy List</h4><ul><li>List变量由<code>[]</code>定义，其元素可以是任意对象，底层对应Java的List接口。</li><li>直接通过索引存取，而且不用担心索引越界，当索引超过当前列表长度，List自动往该索引添加元素。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmp = [<span class="string">"Jerry"</span>, <span class="number">19</span> , <span class="literal">true</span>]</span><br><span class="line">println <span class="string">"tmp[1] = "</span> + tmp[<span class="number">1</span>]</span><br><span class="line">println tmp[<span class="number">5</span>] == <span class="literal">null</span></span><br><span class="line">tmp[<span class="number">10</span>] = <span class="number">3.14</span></span><br><span class="line">println <span class="string">"The size is "</span> + tmp.size</span><br><span class="line">println tmp</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp[1] = 19</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">The size is 11</span><br><span class="line">[Jerry, 19, <span class="literal">true</span>, null, null, null, null, null, null, null, 3.14]</span><br></pre></td></tr></table></figure></p><h4 id="Groovy-Map"><a href="#Groovy-Map" class="headerlink" title="Groovy Map"></a>Groovy Map</h4><ul><li>Map变量由<code>[:]</code>定义，冒号左边是key，右边是value，key必须是字符串，value可以是任何对象。另外key可以用引号包起来，也可以不用。</li><li>Map中元素的存取支持多种方法。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> score = <span class="string">"mark"</span></span><br><span class="line"><span class="comment">// id and name are treated as String</span></span><br><span class="line"><span class="comment">// "$score" is also correct</span></span><br><span class="line">tmp = [<span class="string">id:</span> <span class="number">1</span>, <span class="string">name:</span> <span class="string">"Jerry"</span>, (score): <span class="number">92</span>]</span><br><span class="line">println tmp</span><br><span class="line">println <span class="string">"id: "</span> + tmp.id</span><br><span class="line">println <span class="string">"name: "</span> + tmp[<span class="string">"name"</span>]</span><br><span class="line">tmp.height = <span class="number">183</span></span><br><span class="line">println <span class="string">"height: "</span> + tmp.height</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[id:1, name:Jerry, mark:92]</span><br><span class="line">id: 1</span><br><span class="line">name: Jerry</span><br><span class="line">height: 183</span><br></pre></td></tr></table></figure></p><h4 id="Groovy-Range"><a href="#Groovy-Range" class="headerlink" title="Groovy Range"></a>Groovy Range</h4><ul><li>Range是Groovy对<code>List</code>的扩展，由begin值 + .. + end值定义。</li><li>不包含end值时使用&lt;。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp = <span class="number">1.</span><span class="number">.5</span></span><br><span class="line">println tmp</span><br><span class="line">println tmp.from</span><br><span class="line">println tmp.to</span><br><span class="line">tmpWithoutEnd = <span class="number">1.</span>.&lt;<span class="number">5</span></span><br><span class="line">println tmpWithoutEnd.step(<span class="number">2</span>)</span><br><span class="line">println <span class="string">""</span></span><br><span class="line">println <span class="string">""</span></span><br><span class="line">println tmpWithoutEnd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tmp = <span class="number">1.0</span>f.<span class="number">.5</span><span class="number">.0</span>f</span><br><span class="line">println tmp</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">[1, 3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1.0, 2.0, 3.0, 4.0, 5.0]</span><br></pre></td></tr></table></figure></p><h4 id="Groovy文档"><a href="#Groovy文档" class="headerlink" title="Groovy文档"></a>Groovy文档</h4><ul><li>Groovy的API文档位于<a href="http://www.groovy-lang.org/api.html。" target="_blank" rel="noopener">http://www.groovy-lang.org/api.html。</a></li><li>以Range为例，从getter方法我们知道Range有<code>from</code>和<code>to</code>属性，尽管文档中并没有说明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TgetFrom()</span><br><span class="line">The lower value in the range.</span><br><span class="line">TgetTo()</span><br><span class="line">The upper value in the range.</span><br></pre></td></tr></table></figure><h4 id="Groovy闭包"><a href="#Groovy闭包" class="headerlink" title="Groovy闭包"></a>Groovy闭包</h4><ul><li>英文叫<a href="http://groovy-lang.org/api.html" target="_blank" rel="noopener">Closure</a>，是Groovy中非常重要的一个数据类型或者说一种概念了。</li><li>闭包，是一种数据类型，它代表了一段可执行代码或方法指针。定义格式为：<ul><li><code>def 闭包对象 = { parameters -&gt; code }</code></li><li><code>def 闭包对象 = { code }</code> // 参数个数少于2个时可以省略-&gt;符号</li><li>`def 闭包对象 = reference.&amp;methodName</li></ul></li><li>闭包的调用方式：<ul><li><code>闭包对象.call(参数)</code></li><li><code>闭包对象(参数)</code></li></ul></li><li>闭包只有一个参数时，可省略书写参数，在闭包内使用it变量引用参数。</li><li>闭包可以作为函数返回值，函数参数，可以引用闭包外部定义的变量，可以实现接口方法。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> person = &#123; id, name -&gt;</span><br><span class="line">    println <span class="string">"id=$id, name=$name"</span></span><br><span class="line">&#125;</span><br><span class="line">person(<span class="number">1</span>, <span class="string">"Jerry"</span>)</span><br><span class="line">person.call(<span class="number">2</span>, <span class="string">"Larry"</span>)</span><br><span class="line">person <span class="number">3</span>, <span class="string">"Merry"</span></span><br><span class="line"></span><br><span class="line">Closure resume = &#123; <span class="string">"resume"</span> &#125;</span><br><span class="line">println resume()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> hello = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">def</span> length = hello.&amp;length</span><br><span class="line">println <span class="string">"The length is "</span> + length()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> greeting = &#123; <span class="string">"$hello, $it"</span> &#125;</span><br><span class="line"><span class="comment">// equals: greeting = &#123; it -&gt; "Hello, $it" &#125;</span></span><br><span class="line">println greeting(<span class="string">'Groovy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> exit = &#123; -&gt; <span class="string">"exit"</span> &#125;</span><br><span class="line"><span class="comment">// exit(1) &lt;= wrong!!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> members = [<span class="string">"Jerry"</span>, <span class="string">"Larry"</span>, <span class="string">"Merry"</span>]</span><br><span class="line">members.each &#123;</span><br><span class="line">    println <span class="string">"Hello $it"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> welcome(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        println <span class="string">"Welcome $name"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println welcome(<span class="string">"Terry"</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id=1, name=Jerry</span><br><span class="line">id=2, name=Larry</span><br><span class="line">id=3, name=Merry</span><br><span class="line">resume</span><br><span class="line">The length is 5</span><br><span class="line">Hello, Groovy</span><br><span class="line">Hello Jerry</span><br><span class="line">Hello Larry</span><br><span class="line">Hello Merry</span><br><span class="line">closure<span class="variable">$_welcome_closure6</span>@73a1e9a9</span><br></pre></td></tr></table></figure></p><p>如何确定闭包的参数？<code>查看API文档。</code></p><h4 id="Groovy-DSL"><a href="#Groovy-DSL" class="headerlink" title="Groovy DSL"></a>Groovy DSL</h4><ul><li><code>Command Chain</code>: 链式调用既可以省略圆括号，又可以省略”.”号。</li><li>闭包作为函数调用的最后一个参数时，可以拿到圆括号外面。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent to: turn(left).then(right)</span></span><br><span class="line">turn left then right</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to: take(2.pills).of(chloroquinine).after(6.hours)</span></span><br><span class="line">take <span class="number">2.</span>pills of chloroquinine after <span class="number">6.</span>hours</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to: paint(wall).with(red, green).and(yellow)</span></span><br><span class="line">paint wall with red, green and yellow</span><br><span class="line"></span><br><span class="line"><span class="comment">// with named parameters too</span></span><br><span class="line"><span class="comment">// equivalent to: check(that: margarita).tastes(good)</span></span><br><span class="line">check <span class="string">that:</span> margarita tastes good</span><br><span class="line"></span><br><span class="line"><span class="comment">// with closures as parameters</span></span><br><span class="line"><span class="comment">// equivalent to: given(&#123;&#125;).when(&#123;&#125;).then(&#123;&#125;)</span></span><br><span class="line">given &#123; &#125; when &#123; &#125; then &#123; &#125;</span><br></pre></td></tr></table></figure><p>一个例子：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name(name) &#123;</span><br><span class="line">    println <span class="string">"name: $name"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> age(age) &#123;</span><br><span class="line">    println <span class="string">"age: $age"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> action(String tips, Closure c) &#123;</span><br><span class="line">    println <span class="string">"begin to $tips"</span></span><br><span class="line">    c()</span><br><span class="line">    println <span class="string">"end"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name <span class="string">"Jerry"</span> age <span class="number">18</span></span><br><span class="line"><span class="comment">// name("Jerry").age(18)</span></span><br><span class="line"></span><br><span class="line">name <span class="string">"Herry"</span></span><br><span class="line">age <span class="number">22</span></span><br><span class="line">action(<span class="string">"eat"</span>) &#123;</span><br><span class="line">    println <span class="string">"eating..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name: Jerry</span><br><span class="line">age: 18</span><br><span class="line">name: Herry</span><br><span class="line">age: 22</span><br><span class="line">begin to eat</span><br><span class="line">eating...</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h4 id="Groovy脚本"><a href="#Groovy脚本" class="headerlink" title="Groovy脚本"></a>Groovy脚本</h4><p>Groovy脚本是什么？我们通过一个例子来看一下。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// variables.groovy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> x = <span class="number">1</span> <span class="comment">// or int x = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> printx() &#123;</span><br><span class="line">    println x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printx() <span class="comment">// failed</span></span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Caught: groovy.lang.MissingPropertyException: No such property: x <span class="keyword">for</span> class: variables</span><br><span class="line">groovy.lang.MissingPropertyException: No such property: x <span class="keyword">for</span> class: variables</span><br><span class="line">at variables.printx(variables.groovy:5)</span><br><span class="line">at variables.run(variables.groovy:8)</span><br></pre></td></tr></table></figure></p><p>为何会出现找不到属性<code>x</code>？我们来看看反编译groovy运行时生成的<code>.class</code>文件。使用如下命令在<code>-d</code>指定的目录生成<code>.class</code>文件，然后使用JD-GUI查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyc –d classes variables.groovy</span><br></pre></td></tr></table></figure></p><p><img src="/images/learning-gradle/variables-class.png" alt="variables.class"><br>可以看到：</p><ul><li>XXX.groovy被转换成XXX类，它从<code>Script</code>类派生。</li><li>每一个脚本都会生成一个<code>static main</code>函数。这样，当我们groovy XXX.groovy的时候，其实就是用调用虚拟机去执行这个<code>main</code>函数。</li><li>如果脚本定义了函数，则函数会被定义在XXX类中。</li><li>脚本中的其他代码都会放到<code>run</code>函数中。</li></ul><p>所以变量<code>x</code>是在是在<code>run</code>函数中定义的局部变量，当然无法在<code>printx()</code>函数的访问。那要如何才能实现<code>printx()</code>函数访问变量<code>x</code>呢？有两种方式可以实现。<br>第一种方式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span> <span class="comment">// replace def x = 1 or int x = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> printx() &#123;</span><br><span class="line">    println x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printx()</span><br></pre></td></tr></table></figure></p><p>对应的<code>.class</code>文件反编译代码：<br><img src="/images/learning-gradle/variables-class-x.png" alt><br>另一种方式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.transform.Field;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Field</span> x = <span class="number">1</span> <span class="comment">// &lt;= def x = 1 or int x = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> printx() &#123;</span><br><span class="line">    println x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printx()</span><br></pre></td></tr></table></figure></p><p>对应的<code>.class</code>文件反编译代码：<br><img src="/images/learning-gradle/variables-class-field.png" alt></p><h3 id="Gradle介绍"><a href="#Gradle介绍" class="headerlink" title="Gradle介绍"></a>Gradle介绍</h3><p>Gradle被认为是Java世界构建工具的一次飞跃，它提供：</p><ul><li>一个非常灵活通用的构建工具。</li><li>对多项目构建提供强大支持。</li><li>强大的依赖管理机制。</li><li>完美支持已有的Maven和Ivy仓库。</li><li>支持依赖传递管理。</li><li>脚本编写基于Groovy。</li><li>丰富的描述构建的领域模型。</li></ul><p>更多Gradle特性概述，可以访问<a href="https://docs.gradle.org/3.4.1/userguide/overview.html" target="_blank" rel="noopener">Gradle概述</a>。</p><h3 id="Why-Groovy"><a href="#Why-Groovy" class="headerlink" title="Why Groovy"></a>Why Groovy</h3><p><a href="https://gradle.org/" target="_blank" rel="noopener">Gradle</a>官方网站上对为何选用Groovy来开发的原因描述如下：</p><p>We think the advantages of an internal DSL (based on a dynamic language) over XML are tremendous when used in build scripts. There are a couple of dynamic languages out there. Why Groovy? The answer lies in the context Gradle is operating in. Although Gradle is a general purpose build tool at its core, its main focus are Java projects. In such projects the team members will be very familiar with Java. We think a build should be as transparent as possible to all team members.</p><p>In that case, you might argue why we don’t just use Java as the language for build scripts. We think this is a valid question. It would have the highest transparency for your team and the lowest learning curve, but because of the limitations of Java, such a build language would not be as nice, expressive and powerful as it could be. [1] Languages like Python, Groovy or Ruby do a much better job here. We have chosen Groovy as it offers by far the greatest transparency for Java people. Its base syntax is the same as Java’s as well as its type system, its package structure and other things. Groovy provides much more on top of that, but with the common foundation of Java.</p><p>For Java developers with Python or Ruby knowledge or the desire to learn them, the above arguments don’t apply. The Gradle design is well-suited for creating another build script engine in JRuby or Jython. It just doesn’t have the highest priority for us at the moment. We happily support any community effort to create additional build script engines.</p><h3 id="Gradle基本概念"><a href="#Gradle基本概念" class="headerlink" title="Gradle基本概念"></a>Gradle基本概念</h3><p>Gradle脚本是配置脚本，脚本执行时会配置特定的对象，这些对象被称为脚本的<code>delegate</code>对象。脚本中可以使用<code>delegate</code>对象的属性和方法。所有的Gradle脚本实现了<a href="https://docs.gradle.org/3.4.1/javadoc/" target="_blank" rel="noopener">org.gradle.api.Script</a>接口，所以脚本中可以直接使用Script接口定义的属性和方法，Script接口中找不到的属性或方法将被转交给<code>delegate</code>对象。同时，Gradle脚本也是Groovy脚本，同样可以包含Groovy脚本允许的元素，方法、类定义等。<br><img src="/images/learning-gradle/gradle-delegates.png" alt="gradle-delegates"></p><h3 id="Gradle生命周期"><a href="#Gradle生命周期" class="headerlink" title="Gradle生命周期"></a>Gradle生命周期</h3><p>Gradle执行构建时有它自己的生命周期，概括来说可以分为3个阶段：<br>第一是初始化阶段。初始化阶段Gradle会创建一个<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="noopener">Gradle</a>对象、<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a>对象和<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Root Project</a>对象，然后在项目根目录寻找并执行<code>settings.gradle</code>文件来配置<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a>对象，并生成项目的<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>树。</p><p>第二是配置阶段。配置阶段Gradle会执行特定的构建脚本，默认是各<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>目录下名为<code>build.gradle</code>的文件，以配置对应的<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>。配置阶段结束时，Gradle内部会生成整个项目的有向无循环<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>图。</p><p>第三是执行阶段。执行阶段Gradle依据命令行传入的<code>task</code>名字在<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>图中找出此<code>task</code>的所有依赖链，并从各依赖链起点开始，沿着依赖链依次执行<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>，最终得到编译产物。<br><img src="/images/learning-gradle/gradle-build-phases.png" alt="gradle-build-phasesM"></p><p>Gradle用户手册中关于Gradle生命周期的描述如下：<br><img src="/images/learning-gradle/gradle-lifecycle.png" alt="gradle-lifecycle"></p><p>Gradle生命周期的例子如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">println <span class="string">'This is executed during the initialization phase.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// build.gradle in root directory</span></span><br><span class="line">println <span class="string">'This is executed during the configuration phase.'</span></span><br><span class="line"></span><br><span class="line">task configured &#123;</span><br><span class="line">    println <span class="string">'This is also executed during the configuration phase.'</span></span><br><span class="line">&#125;</span><br><span class="line">task test &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'This is executed during the execution phase.'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task testBoth &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">      println <span class="string">'This is executed first during the execution phase.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">      println <span class="string">'This is executed last during the execution phase.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    println <span class="string">'This is executed during the configuration phase as well.'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is executed during the initialization phase.</span><br><span class="line">This is executed during the configuration phase.</span><br><span class="line">This is also executed during the configuration phase.</span><br><span class="line">This is executed during the configuration phase as well.</span><br></pre></td></tr></table></figure></p><h4 id="Gradle生命周期Hook"><a href="#Gradle生命周期Hook" class="headerlink" title="Gradle生命周期Hook"></a>Gradle生命周期Hook</h4><p>Gradle提供了丰富的Hook机制以获知Gradle生命周期各个阶段各类事件的发生。常用的Hook可以通过<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a>对象，<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>或<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>对象来设置，设置方式包括配置闭包方式和设置监听器方式。<br><img src="/images/learning-gradle/gradle-lifecycle-phases-hook.png" alt="gradle-lifecycle-phases-hook"></p><p>以项目评估结束事件为例说明：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle in root directory</span></span><br><span class="line">afterEvaluate &#123;</span><br><span class="line">    println <span class="string">"Project $name has been evaluated."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.afterProject &#123;</span><br><span class="line">    println <span class="string">"Project $it.name is evaluated."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.addProjectEvaluationListener(<span class="keyword">new</span> ProjectEvaluationListener() &#123;</span><br><span class="line">    <span class="keyword">void</span> afterEvaluate(Project project, ProjectState state) &#123;</span><br><span class="line">        println <span class="string">"Project $project.name was evaluated."</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> beforeEvaluate(Project project) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Project tutorial was evaluated.</span><br><span class="line">Project tutorial is evaluated.</span><br><span class="line">Project tutorial has been evaluated.</span><br></pre></td></tr></table></figure></p><h3 id="Gradle核心组件"><a href="#Gradle核心组件" class="headerlink" title="Gradle核心组件"></a>Gradle核心组件</h3><p>Gradle的核心组件包括<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="noopener">Gradle</a>，<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a>，<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>，<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>，<a href="https://docs.gradle.org/3.4.1/userguide/dependency_management.html" target="_blank" rel="noopener">Dependency</a>，<a href="https://docs.gradle.org/3.4.1/userguide/plugins.html" target="_blank" rel="noopener">Plugin</a>等，每个核心组件都对应很多有用的属性、方法和脚本块。</p><h4 id="Gradle组件"><a href="#Gradle组件" class="headerlink" title="Gradle组件"></a>Gradle组件</h4><p><a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="noopener">Gradle</a>组件代表了一次Gradle构建，通过Gradle组件能够获取（或设置）本次构建的一些全局信息，包括<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:gradleVersion" target="_blank" rel="noopener">gradleVersion</a>，<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:taskGraph" target="_blank" rel="noopener">taskGraph</a>，所有用到的<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:plugins" target="_blank" rel="noopener">plugins</a>及添加各种Hook等。</p><h4 id="Settings组件"><a href="#Settings组件" class="headerlink" title="Settings组件"></a>Settings组件</h4><p><a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a>实例与<code>settings.gradle</code>文件存在一一对应关系，Gradle执行时会使用<code>settings.gradle</code>来配置对应的Settings实例。通常，在<code>settings.gradle</code>脚本中会通过<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">include(String[])</a>方法来添加对多项目的支持。<code>Root Project</code>会在Settings对象被创建时自动添加。另外，Settings组件还支持动态属性，除了对象接口本身的属性，还包含如下可用的属性：</p><ul><li>与<code>setting.gradle</code>同级的<code>gradle.properites</code>文件定义的属性。</li><li>用户Gradle目录里<code>gradle.properties</code>定义的属性。</li><li>通过命令行-P参数定义的属性。</li></ul><p>示例如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gradle.properties in project root directory</span></span><br><span class="line">componentized=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line"><span class="keyword">if</span> (componentized) &#123;</span><br><span class="line">    include <span class="string">':components'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Project tutorial was evaluated.</span><br><span class="line">Project tutorial is evaluated.</span><br><span class="line">Project tutorial has been evaluated.</span><br><span class="line">Project components was evaluated.</span><br><span class="line">Project components is evaluated.</span><br></pre></td></tr></table></figure></p><h4 id="Project组件"><a href="#Project组件" class="headerlink" title="Project组件"></a>Project组件</h4><p><a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>组件是编译脚本与Gradle交互的主API接口，通过Project接口能访问Gradle所有功能。Gradle运行时使用<code>build.gradle</code>配置对应的project对象。一个Project本质上一些列<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>的集合，每一个<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>执行一定的任务（类编译，生成javadoc等）。Project配置通常包括仓库，依赖，产物，分组配置，插件的管理。所有Project将都将被加入到Project层次树中，Project全路径是其在层次树中的唯一标识。Project配置还可以引入插件，插件可以使得Project配置更加模块化，并可重用。Project组件还支持5大范围的动态属性和5大范围的动态方法。</p><p>5大范围动态属性<br><img src="/images/learning-gradle/project-5-property-scopes.png" alt="project-5-property-scopes"></p><p>5大范围动态方法<br><img src="/images/learning-gradle/project-5-method-scopes.png" alt="project-5-method-scopes"></p><p>Ext属性示例：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle in root directory</span></span><br><span class="line">ext &#123;</span><br><span class="line">    gradleVersion = <span class="string">"3.4"</span></span><br><span class="line">    isSnapshot = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">ext.javaVersion = <span class="string">"1.7"</span></span><br><span class="line"></span><br><span class="line">task addProperty(<span class="string">dependsOn:</span> clean) &#123;</span><br><span class="line">    project.ext.prop3 = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isSnapshot) &#123;</span><br><span class="line">    println <span class="string">"GradleVersion: $gradleVersion"</span></span><br><span class="line">    println <span class="string">"JavaVersion: $javaVersion"</span></span><br><span class="line">    println <span class="string">"Prop3: $&#123;prop3&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build.gradle in components directory</span></span><br><span class="line">println <span class="string">"GradleVersion in components: $gradleVersion"</span></span><br><span class="line">println <span class="string">"JavaVersion in components: $&#123;rootProject.ext.javaVersion&#125;"</span></span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GradleVersion: 3.4</span><br><span class="line">JavaVersion: 1.7</span><br><span class="line">Prop3: <span class="literal">true</span></span><br><span class="line">GradleVersion <span class="keyword">in</span> components: 3.4</span><br><span class="line">JavaVersion <span class="keyword">in</span> components: 1.7</span><br></pre></td></tr></table></figure></p><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>Gradle的<a href="https://docs.gradle.org/3.4.1/userguide/dependency_management.html" target="_blank" rel="noopener">依赖管理</a>主要包括2大块：</p><ul><li>解决依赖。依赖指使得项目能够正常编译或运行的输入组件。<ul><li>依赖配置：包括项目内依赖和外部依赖，并以配置分组。</li><li>仓库配置：Gradle会在配置的仓库地址查找外部依赖。</li></ul></li><li>发布产物。产物指项目编译生成的或需要上传到中心的仓库的输出产物。<ul><li>配置发布仓库。通常插件会定义好项目的产物，我们不必关心，但必须告诉Gradle将产物发布到何处，<a href="https://search.maven.org/" target="_blank" rel="noopener">MavenCentral</a>，Ivy仓库，<a href="https://bintray.com/bintray/jcenter" target="_blank" rel="noopener">JCenter</a>等。</li></ul></li></ul><p>Gradle有6大类型依赖，如下图，其中比较常用的包括<a href="https://docs.gradle.org/3.4.1/userguide/dependency_management.html#sub:module_dependencies" target="_blank" rel="noopener">External module dependency</a>，<a href="https://docs.gradle.org/3.4.1/userguide/dependency_management.html#sub:project_dependencies" target="_blank" rel="noopener">Project dependency</a>，<a href="https://docs.gradle.org/3.4.1/userguide/dependency_management.html#sub:file_dependencies" target="_blank" rel="noopener">File dependency</a>。<br><img src="/images/learning-gradle/dependency-types.png" alt="dependency-types"></p><p>依赖管理示例：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In this section you declare where to find the dependencies of your project</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    jcenter &#123;</span><br><span class="line">        url <span class="string">"http://jcenter.bintray.com/"</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">"http://repo.company.com/maven2"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url <span class="string">"../local-repo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.google.guava:guava:20.0'</span></span><br><span class="line">    compile project(<span class="string">':components'</span>)</span><br><span class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> <span class="string">'*.jar'</span>)</span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Task组件"><a href="#Task组件" class="headerlink" title="Task组件"></a>Task组件</h4><p>Gradle task represents some atomic piece of work which a build performs。<a href="https://docs.gradle.org/3.4.1/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a>可以使用<code>task</code>关键字定义，也可以使用<a href="https://docs.gradle.org/3.4.1/javadoc/org/gradle/api/tasks/TaskContainer.html" target="_blank" rel="noopener">TaskContainer.create()</a>来定义。一个Task可以依赖于另一个Task，Gradle支持使用<code>must run after</code>和<code>should run after</code>直接控制2个Task的执行顺序。预定义的Task可以被替换。<br>另外Task还支持4大范围动态属性和通过<a href="https://docs.gradle.org/3.4.1/javadoc/org/gradle/api/plugins/Convention.html" target="_blank" rel="noopener">Convention</a>对象支持动态方法。</p><p>4大范围动态属性<br><img src="/images/learning-gradle/task-4-property-scopes.png" alt="task-4-property-scopes"></p><p>Task使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// build.gradle in root project</span><br><span class="line">task hello1 &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;Hello1 Task&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task hello2 &lt;&lt; &#123;</span><br><span class="line">    ext.prop2 = &quot;prop2&quot;</span><br><span class="line">    println &quot;Hello2 Task&quot;</span><br><span class="line">&#125;</span><br><span class="line">hello2.dependsOn hello1</span><br><span class="line">task(hello3, dependsOn: hello2) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println &quot;Prop2: $&#123;hello2.ext.prop2&#125;&quot;</span><br><span class="line">        println &quot;Hello3 Task&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.create(&apos;hello4&apos;).dependsOn(&apos;hello3&apos;)</span><br><span class="line">hello4.doLast &#123;</span><br><span class="line">    println &quot;Hello4 Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:hello1</span><br><span class="line">Hello1 Task</span><br><span class="line">:hello2</span><br><span class="line">Hello2 Task</span><br><span class="line">:hello3</span><br><span class="line">Prop2: prop2</span><br><span class="line">Hello3 Task</span><br><span class="line">:hello4</span><br><span class="line">Hello4 Task</span><br></pre></td></tr></table></figure></p><h4 id="Plugin组件"><a href="#Plugin组件" class="headerlink" title="Plugin组件"></a>Plugin组件</h4><p><a href="https://docs.gradle.org/3.4.1/userguide/plugins.html" target="_blank" rel="noopener">Gradle插件</a>就是将很多可在多个不同项目或构建中重用的编译逻辑（属性、方法和Task等）打包起来。可以使用不同的语言来实现插件，如Groovy，Java，Scala，插件最终被编译成字节码。插件源码可位于3类地方：</p><ul><li>Build script：插件自动被编译并被include到<code>classpath</code>中，build script外不可用。</li><li>buildSrc project：<code>buildSrc</code>子项目自动被编译并被include到<code>classpath</code>中，整个项目可用，其他项目不可用。</li><li>Standalone project：可以发布jar或发布到公共仓库，其他项目可用。</li></ul><h3 id="Gradle-Wrapper目录结构"><a href="#Gradle-Wrapper目录结构" class="headerlink" title="Gradle Wrapper目录结构"></a>Gradle Wrapper目录结构</h3><p><a href="https://docs.gradle.org/3.4.1/userguide/gradle_wrapper.html" target="_blank" rel="noopener">Gradle Wrapper</a>可以使得每个项目拥有各自的Gradle版本而不互相影响。当前项目中Gradle相关文件说明如下：<br><img src="/images/learning-gradle/gradle-wrapper-in-project.png" alt="gradle-wrapper-in-project"></p><p>用户主目录下Gradle相关文件说明如下：<br><img src="/images/learning-gradle/gradle-wrapper-in-home.png" alt="gradle-wrapper-in-home"></p><h3 id="Android-Plugin-for-Gradle"><a href="#Android-Plugin-for-Gradle" class="headerlink" title="Android Plugin for Gradle"></a>Android Plugin for Gradle</h3><p>Android Plugin for Gradle就是通过Gradle插件机制方式实现Gradle在Android平台的扩展，详细信息请参考<a href="http://tools.android.com/tech-docs/new-build-system/user-guide" target="_blank" rel="noopener">Gradle Plugin User Guide</a>和<a href="https://google.github.io/android-gradle-dsl/" target="_blank" rel="noopener">Android Gradle DSL Reference</a>。</p><hr><p>参考</p><ul><li><a href="http://groovy-lang.org/" target="_blank" rel="noopener">http://groovy-lang.org/</a></li><li><a href="https://docs.gradle.org/3.4.1/userguide/userguide.html" target="_blank" rel="noopener">https://docs.gradle.org/3.4.1/userguide/userguide.html</a></li><li><a href="https://docs.gradle.org/3.4.1/dsl/" target="_blank" rel="noopener">https://docs.gradle.org/3.4.1/dsl/</a></li><li><a href="http://tools.android.com/" target="_blank" rel="noopener">http://tools.android.com/</a></li><li><a href="https://github.com/google/android-gradle-dsl" target="_blank" rel="noopener">https://github.com/google/android-gradle-dsl</a></li><li><a href="http://blog.csdn.net/suncaishen/article/details/6194706" target="_blank" rel="noopener">http://blog.csdn.net/suncaishen/article/details/6194706</a></li><li><a href="http://blog.csdn.net/kmyhy/article/details/4200563" target="_blank" rel="noopener">http://blog.csdn.net/kmyhy/article/details/4200563</a></li><li><a href="http://jijiaxin89.com/2015/08/29/gradle-use-note/" target="_blank" rel="noopener">http://jijiaxin89.com/2015/08/29/gradle-use-note/</a></li><li><a href="https://developer.android.com/studio/build/gradle-tips.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-tips.html</a></li><li><a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/android-in-depth-gradle</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio&lt;/a&gt;作为Android应用开发的官方IDE，默认使用&lt;a href=&quot;https://www.gradle.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gradle&lt;/a&gt;作为构建工具，所以对于&lt;a href=&quot;https://developer.android.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android应用开发&lt;/a&gt;来说，Gradle是必须要掌握的工具。然而现实是，很多Android应用开发人员都不太了解Gradle，并且网上大部分关于&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Gradle&lt;/a&gt;的资料都是帮助解决某个具体的配置问题，缺乏系统深入的讲解。本文就来系统且深入的学习&lt;a href=&quot;https://www.gradle.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gradle&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://feilongwang.org/tags/Android/"/>
    
      <category term="Gradle" scheme="https://feilongwang.org/tags/Gradle/"/>
    
      <category term="Build" scheme="https://feilongwang.org/tags/Build/"/>
    
      <category term="构建" scheme="https://feilongwang.org/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="编译" scheme="https://feilongwang.org/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源许可证</title>
    <link href="https://feilongwang.org/2016/06/21/How-to-Choose-an-Open-Source-License/"/>
    <id>https://feilongwang.org/2016/06/21/How-to-Choose-an-Open-Source-License/</id>
    <published>2016-06-20T16:09:48.000Z</published>
    <updated>2020-03-01T02:17:43.947Z</updated>
    
    <content type="html"><![CDATA[<p>对于软件产品，无论是免费发布还是出售，制定一份许可协议都非常有用。否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作者身份，对于后者，你将不得不花费比开发更多的精力用来逐个处理授权问题。许可，就是提供给使用你产品的人有一定的权限，不过你仍然拥有版权和专利（如果申请了的话）。<a href="https://en.wikipedia.org/wiki/Open-source_license" target="_blank" rel="noopener">开源许可证</a>使得我们发布开源软件产品变得简单。<br><a id="more"></a></p><p>现今存在的开源许可证很多，多数人搞不清楚他们之间的区别。很多程序员在开源代码的时候不知如何选择开源许可证，或者使用别人的开源代码时未遵循其原始许可证。如何选择开源许可证，这是一个问题。</p><p>通过OSI(<a href="https://opensource.org" target="_blank" rel="noopener">Open Source Initiative</a>)组织批准的许可证目前有78种。当前流行的6种GPL，LGPL，Apache，MIT，BSD和MPL都是OSI批准的许可证。GitHub建了一个很赞的网站<a href="https://choosealicense.com/" target="_blank" rel="noopener">Choose an open source license</a>，提供了各主流许可证的协议文本，并对它们作了详细的介绍和比较。国内阮一峰的BLOG也提供了一张简洁的<a href="http://image.beekka.com/blog/201105/free_software_licenses.png" target="_blank" rel="noopener">分析图</a>（LGPL和MPL许可证描述有误）。</p><h3 id="MIT许可证"><a href="#MIT许可证" class="headerlink" title="MIT许可证"></a>MIT许可证</h3><p><a href="https://opensource.org/licenses/mit-license.php" target="_blank" rel="noopener">MIT许可证</a>是一个简短、宽松的许可证，唯一的要求就是保留原始版权和许可声明。你可以：</p><ul><li>商业使用。软件及衍生产品可以用于商业目的。</li><li>自由地修改、发布。软件可以被自由地拷贝、修改、发布。</li></ul><h3 id="BSD许可证"><a href="#BSD许可证" class="headerlink" title="BSD许可证"></a>BSD许可证</h3><p><a href="https://opensource.org/licenses/BSD-3-Clause" target="_blank" rel="noopener">BSD许可证</a>是一个给予使用者很大自由的许可证。使用者可以自由的使用、修改源代码，也可以将修改后的代码作为开源或专有软件再发布，只须满足：</p><ul><li>如果再发布的产品是源代码，则在源代码中必须包含原始版权和许可声明。</li><li>如果再发布产品是二进制形式，则需要在其文档和版权申明包含原始版权和许可声明。</li><li>未经事先书面许可，不得使用原作者/机构的名字和原产品名字进行衍生产品的推广。</li></ul><h3 id="Apache许可证"><a href="#Apache许可证" class="headerlink" title="Apache许可证"></a>Apache许可证</h3><p><a href="https://opensource.org/licenses/Apache-2.0" target="_blank" rel="noopener">Apache许可证</a>是一个宽松且专业的许可证，相比于其他许可证，软件产品可以自由修改、发布和商用，该许可证还为用户提供专利许可，只须满足以下条件：</p><ul><li>包含一份原始许可声明和版权声明</li><li>如果修改了源代码，包含一份代码修改说明。</li><li>不得使用其原始商标</li></ul><h3 id="GPL许可证"><a href="#GPL许可证" class="headerlink" title="GPL许可证"></a>GPL许可证</h3><p><a href="https://www.gnu.org/licenses/gpl.html" target="_blank" rel="noopener">GPL(GNU General Public License)许可证</a>是一个开放源码许可证，只要在软件产品中使用（“使用”指类库引用，修改后的代码或者衍生代码）GPL许可证的产品，则该软件产品也必须采用GPL许可证发布，并且不论以何种形式发布，都必须同时附上源代码。这就是所谓的<strong>“传染性”</strong>。其他细节与Apache许可证类似，如：</p><ul><li>软件及衍生产品可以用于商业目的。</li><li>产品可以被自由地分发、修改。</li><li>同时提供额外的专利授权。</li><li>产品再发布时包含一份原始许可声明和版权声明。</li><li>如果修改了源代码，包含一份代码修改说明。</li></ul><h3 id="LGPL许可证"><a href="#LGPL许可证" class="headerlink" title="LGPL许可证"></a>LGPL许可证</h3><p><a href="https://www.gnu.org/licenses/lgpl.html" target="_blank" rel="noopener">LGPL( GNU Lesser General Public License)许可证</a>是一个主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。其他细节与GPL许可证类似，如：</p><ul><li>同时提供额外的专利授权。</li><li>产品再发布时包含一份原始许可声明和版权声明。</li><li>如果修改了源代码，包含一份代码修改说明。</li></ul><h3 id="MPL许可证"><a href="#MPL许可证" class="headerlink" title="MPL许可证"></a>MPL许可证</h3><p><a href="https://www.mozilla.org/media/MPL/2.0/index.txt" target="_blank" rel="noopener">MPL(Mozilla Public License)许可证</a>是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。与著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同，但是，相比而言，MPL还有以下几个显著的特点:</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的使用、修改也要以MPL许可证的方式再许可出来（开源），以保证其他人可以在MPL的条款下共享源代码。但是，在MPL许可证对于衍生代码没有要求，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。</li><li>软件产品再发布时包含一份原始许可声明和版权声明。</li><li>提供快速的专利授权。</li><li>不得使用其原始商标。</li><li>如果修改了源代码，包含一份代码修改说明。</li></ul><p><strong>以上所有许可证都支持私有使用，即使用和修改软件但不对外发布。</strong></p><h3 id="The-Unlicense"><a href="#The-Unlicense" class="headerlink" title="The Unlicense"></a>The Unlicense</h3><p><a href="http://unlicense.org/UNLICENSE" target="_blank" rel="noopener">The Unlicense</a>是一个放弃所有权利的许可证，没有任何限制，它一般用在致力于公有领域的产品。</p><p><strong>开源许可证也可用于非软件产品，尤其是那些能够被当做源码编辑和管理的产品，如开源硬件设计等。</strong></p><p>如果你的产品不是软件产品(数据、多媒体等)，也有一些开源许可证可供选择。</p><h3 id="Creative-Commons许可证"><a href="#Creative-Commons许可证" class="headerlink" title="Creative Commons许可证"></a>Creative Commons许可证</h3><p><a href="https://creativecommons.org/" target="_blank" rel="noopener">Creative Commons</a>简称CC，中国大陆正式名称为知识共享。传统的著作权通常为两种极端，一种是”保留所有权利”，另一种是“不保留任何权利”（即公有领域，public domain）。知识共享则试图在两者中间广大的灰色地带保有弹性，使创作者可以“保留部分权利”。创作者可与大众分享创作，授予其他人再散布的权利，却又能保留其他某些权利。知识共享一般用于设计，摄影，图片作品的开放式分享，并提供多种可供选择的授权形式及条款组合：</p><ul><li>署名（Attribution，简写为BY）：必须提到原作者。</li><li>非商业用途（Noncommercial，简写为NC）：不得用于盈利性目的。</li><li>禁止演绎（No Derivative Works，简写为ND）：不得修改原作品，不得再创作。</li><li>相同方式共享（Share Alike，简写为SA）：允许修改原作品，但必须使用相同的许可证发布。</li></ul><blockquote><p>知识共享协议不能同时包含“相同方式共享”和“禁止演绎”许可要素，“相同方式共享”要素仅适用于演绎作品。*</p></blockquote><p>这些授权形式可以结合起来用，如CC BY，CC BY-NC-SA等。</p><hr><p>参考：</p><ol><li><a href="http://www.awflasher.com/blog/archives/939" target="_blank" rel="noopener">http://www.awflasher.com/blog/archives/939</a></li><li><a href="http://www.cnblogs.com/findumars/p/3496807.html" target="_blank" rel="noopener">http://www.cnblogs.com/findumars/p/3496807.html</a></li><li><a href="https://choosealicense.com/licenses/" target="_blank" rel="noopener">https://choosealicense.com/licenses/</a></li><li><a href="https://www.oschina.net/question/12_2827" target="_blank" rel="noopener">https://www.oschina.net/question/12_2827</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于软件产品，无论是免费发布还是出售，制定一份许可协议都非常有用。否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作者身份，对于后者，你将不得不花费比开发更多的精力用来逐个处理授权问题。许可，就是提供给使用你产品的人有一定的权限，不过你仍然拥有版权和专利（如果申请了的话）。&lt;a href=&quot;https://en.wikipedia.org/wiki/Open-source_license&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开源许可证&lt;/a&gt;使得我们发布开源软件产品变得简单。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://feilongwang.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="许可证" scheme="https://feilongwang.org/tags/%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
    
      <category term="开源" scheme="https://feilongwang.org/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
</feed>
